"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.inspecControlToRubyCode = exports.impactNumberToSeverityString = exports.severityStringToImpact = exports.convertEncodedHTMLIntoJson = exports.convertEncodedXmlIntoJson = exports.wrapAndEscapeQuotes = exports.escapeDoubleQuotes = exports.escapeQuotes = exports.wrap = void 0;
const tslib_1 = require("tslib");
const fast_xml_parser_1 = tslib_1.__importDefault(require("fast-xml-parser"));
const htmlparser = tslib_1.__importStar(require("htmlparser2"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
// Breaks lines down to lineLength number of characters
function wrap(s, lineLength = 80) {
    let currentLineLength = 0;
    let finalString = '';
    s.split(' ').forEach(word => {
        if (currentLineLength + word.length < lineLength || word.length >= lineLength) {
            currentLineLength += word.length;
            finalString += word + ' ';
        }
        else {
            currentLineLength = word.length;
            finalString += `\n${word} `;
        }
    });
    return finalString;
}
exports.wrap = wrap;
const escapeQuotes = (s) => s.replace(/\\/g, '\\\\').replace(/'/g, "\\'"); // Escape backslashes and quotes
exports.escapeQuotes = escapeQuotes;
const escapeDoubleQuotes = (s) => s.replace(/\\/g, '\\\\').replace(/"/g, '\\"'); // Escape backslashes and double quotes
exports.escapeDoubleQuotes = escapeDoubleQuotes;
const wrapAndEscapeQuotes = (s, lineLength) => (0, exports.escapeDoubleQuotes)(wrap(s, lineLength)); // Escape backslashes and quotes, and wrap long lines
exports.wrapAndEscapeQuotes = wrapAndEscapeQuotes;
function convertEncodedXmlIntoJson(encodedXml) {
    return fast_xml_parser_1.default.parse(encodedXml, {
        ignoreAttributes: false,
        attributeNamePrefix: '@_',
    });
}
exports.convertEncodedXmlIntoJson = convertEncodedXmlIntoJson;
function convertEncodedHTMLIntoJson(encodedHTML) {
    if (encodedHTML) {
        // Some STIGs regarding XSS put the < character inside of the description which breaks parsing
        const patchedHTML = encodedHTML.replace(/"&lt;"/g, '[[[REPLACE_LESS_THAN]]]');
        const xmlChunks = [];
        const htmlParser = new htmlparser.Parser({
            ontext(text) {
                xmlChunks.push(text);
            },
        });
        htmlParser.write(patchedHTML);
        htmlParser.end();
        const converted = convertEncodedXmlIntoJson(xmlChunks.join(''));
        let cleaned = {};
        if (typeof converted.VulnDiscussion === 'object') { // Some STIGs have xml tags inside of the actual text which breaks processing, e.g U_ASD_STIG_V5R1_Manual-xccdf.xml and all Oracle Database STIGs
            let extractedVulnDescription = '';
            const remainingFields = lodash_1.default.omit(converted.VulnDiscussion, ['FalsePositives', 'FalseNegatives', 'Documentable', 'Mitigations', 'SeverityOverrideGuidance', 'PotentialImpacts', 'ThirdPartyTools', 'MitigationControl', 'Responsibility', 'IAControls']);
            Object.entries(remainingFields).forEach(([field, value]) => {
                extractedVulnDescription += `<${field}> ${value}`;
            });
            cleaned = {
                VulnDiscussion: extractedVulnDescription.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"'),
            };
            Object.entries(converted.VulnDiscussion).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    cleaned[key] = value.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"');
                }
                else {
                    cleaned[key] = value;
                }
            });
        }
        else {
            Object.entries(converted).forEach(([key, value]) => {
                if (typeof value === 'string') {
                    cleaned[key] = value.replace(/\[\[\[REPLACE_LESS_THAN]]]/, '"<"');
                }
                else {
                    cleaned[key] = value;
                }
            });
        }
        return cleaned;
    }
    return {};
}
exports.convertEncodedHTMLIntoJson = convertEncodedHTMLIntoJson;
function severityStringToImpact(string) {
    if (/none|na|n\/a|not[\s()*_|]?applicable/i.test(string)) {
        return 0.0;
    }
    if (/low|cat(egory)?\s*(iii|3)/i.test(string)) {
        return 0.3;
    }
    if (/med(ium)?|cat(egory)?\s*(ii|2)/i.test(string)) {
        return 0.5;
    }
    if (/high|cat(egory)?\s*(i|1)/i.test(string)) {
        return 0.7;
    }
    if (/crit(ical)?|severe/i.test(string)) {
        return 1.0;
    }
    throw new Error(`${string}' is not a valid severity value. It should be one of the approved keywords`);
}
exports.severityStringToImpact = severityStringToImpact;
function impactNumberToSeverityString(impact) {
    // Impact must be 0.0 - 1.0
    if (impact < 0.0 || impact > 1.0) {
        throw new Error('Impact cannot be less than 0.0 or greater than 1.0');
    }
    else {
        if (impact >= 0.9) {
            return 'critical';
        }
        if (impact >= 0.7) {
            return 'high';
        }
        if (impact >= 0.4) {
            return 'medium';
        }
        if (impact >= 0.1) {
            return 'low';
        }
        return 'none';
    }
}
exports.impactNumberToSeverityString = impactNumberToSeverityString;
function inspecControlToRubyCode(control, lineLength, showUtfEncoding) {
    let result = showUtfEncoding ? '# encoding: UTF-8\n\n' : '';
    result += `control "${control.id}" do\n`;
    if (control.title) {
        result += `  title "${(0, exports.wrapAndEscapeQuotes)(control.title, lineLength)}"\n`;
    }
    else {
        console.error(`${control.id} does not have a title`);
    }
    if (control.desc) {
        result += `  desc "${(0, exports.wrapAndEscapeQuotes)(control.desc, lineLength)}"\n`;
    }
    else {
        console.error(`${control.id} does not have a desc`);
    }
    if (control.descs) {
        Object.entries(control.descs).forEach(([key, desc]) => {
            if (desc) {
                result += `  desc "${key}", "${(0, exports.wrapAndEscapeQuotes)(desc, lineLength)}"\n`;
            }
            else {
                console.error(`${control.id} does not have a desc for the value ${key}`);
            }
        });
    }
    if (control.impact) {
        result += `  impact ${control.impact}\n`;
    }
    else {
        console.error(`${control.id} does not have an impact, please define impact within your mapping file or set tags.severity to set automatically`);
    }
    if (control.refs) {
        control.refs.forEach(ref => {
            result += `  ref '${(0, exports.escapeQuotes)(ref)}'\n`;
        });
    }
    Object.entries(control.tags).forEach(([tag, value]) => {
        if (value) {
            if (typeof value === 'object') {
                if (Array.isArray(value) && typeof value[0] === 'string') {
                    result += `  tag ${tag}: ${JSON.stringify(value)}\n`;
                }
                else {
                    // Convert JSON Object to Ruby Hash
                    const stringifiedObject = JSON.stringify(value, null, 2)
                        .replace(/\n/g, '\n  ')
                        .replace(/\{\n {6}/g, '{')
                        .replace(/\[\n {8}/g, '[')
                        .replace(/\n {6}\]/g, ']')
                        .replace(/\n {4}\}/g, '}')
                        .replace(/": \[/g, '" => [');
                    result += `  tag ${tag}: ${stringifiedObject}\n`;
                }
            }
            else if (typeof value === 'string') {
                result += `  tag ${tag}: "${(0, exports.wrapAndEscapeQuotes)(value, lineLength)}"\n`;
            }
        }
    });
    result += 'end';
    return result;
}
exports.inspecControlToRubyCode = inspecControlToRubyCode;
