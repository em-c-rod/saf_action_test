"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const command_1 = require("@oclif/command");
const inspecjs_1 = require("inspecjs");
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
const fs_1 = (0, tslib_1.__importDefault)(require("fs"));
const objects_to_csv_1 = (0, tslib_1.__importDefault)(require("objects-to-csv"));
const csv_1 = require("../../utils/csv");
const global_1 = require("../../utils/global");
class HDF2CSV extends command_1.Command {
    convertRows(evaluation, filename, fieldsToAdd) {
        const controls = evaluation.contains.flatMap(profile => profile.contains) || [];
        return controls.map(ctrl => (0, csv_1.convertRow)(filename, ctrl, fieldsToAdd));
    }
    async run() {
        const { flags } = this.parse(HDF2CSV);
        const contextualizedEvaluation = (0, inspecjs_1.contextualizeEvaluation)(JSON.parse(fs_1.default.readFileSync(flags.input, 'utf-8')));
        // Convert all controls from a file to ControlSetRows
        let rows = this.convertRows(contextualizedEvaluation, (0, global_1.convertFullPathToFilename)(flags.input), flags.fields.split(','));
        rows = rows.map((row, index) => {
            const cleanedRow = {};
            for (const key in row) {
                if ((row[key]).length > 32767) {
                    if ('ID' in row) {
                        console.error(`Field ${key} of control ${row.ID} is longer than 32,767 characters and has been truncated for compatibility with Excel. To disable this behavior use the option --noTruncate`);
                    }
                    else {
                        console.error(`Field ${key} of control at index ${index} is longer than 32,767 characters and has been truncated for compatibility with Excel. To disable this behavior use the option --noTruncate`);
                    }
                    cleanedRow[key] = lodash_1.default.truncate(row[key], { length: 32757, omission: 'TRUNCATED' });
                }
                else {
                    cleanedRow[key] = row[key];
                }
            }
            return cleanedRow;
        });
        await new objects_to_csv_1.default(rows).toDisk(flags.output);
    }
}
exports.default = HDF2CSV;
HDF2CSV.usage = 'hdf2csv -i, --input <INPUT-JSON> -o, --output <OUTPUT-CSV> -f, --fields <CSV Fields>';
HDF2CSV.description = 'Translate a Heimdall Data Format JSON file into a Comma Separated Values (CSV) file';
HDF2CSV.flags = {
    help: command_1.flags.help({ char: 'h' }),
    input: command_1.flags.string({ char: 'i', required: true, description: 'Input HDF file' }),
    output: command_1.flags.string({ char: 'o', required: true, description: 'Output CSV file' }),
    fields: command_1.flags.string({ char: 'f', required: false, default: csv_1.csvExportFields.join(','), description: 'Fields to include in output CSV, separated by commas' }),
    noTruncate: command_1.flags.boolean({ char: 't', required: false, default: false, description: "Don't truncate fields longer than 32,767 characters (the cell limit in Excel)" }),
};
HDF2CSV.examples = ['saf convert:hdf2csv -i rhel7-results.json -o rhel7.csv --fields "Results Set,Status,ID,Title,Severity"'];
