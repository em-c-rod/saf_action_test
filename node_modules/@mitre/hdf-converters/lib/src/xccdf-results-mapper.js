"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XCCDFResultsMapper = void 0;
const fast_xml_parser_1 = __importDefault(require("fast-xml-parser"));
const htmlparser = __importStar(require("htmlparser2"));
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const CciNistMapping_1 = require("./mappings/CciNistMapping");
const IMPACT_MAPPING = new Map([
    ['critical', 0.9],
    ['high', 0.7],
    ['medium', 0.5],
    ['low', 0.3]
]);
const CCI_NIST_MAPPING = new CciNistMapping_1.CciNistMapping();
const DEFAULT_NIST_TAG = ['SA-11', 'RA-5', 'Rev_4'];
const RULE_RESULT_PATHS = ['cdf:rule-result', 'rule-result'];
let idTracker = '';
let valueIdTracker = undefined;
function getRuleResultItem(testResult, pathRuleResultPossibilities, pathIdRefPossibilities = ['idref'], pathItemPossibilities = undefined) {
    for (const pathRuleResult of pathRuleResultPossibilities) {
        const ruleResult = lodash_1.default.get(testResult, pathRuleResult);
        if (ruleResult === undefined) {
            continue;
        }
        const match = ruleResult.find((element) => lodash_1.default.some(pathIdRefPossibilities.map((pathIDRef) => lodash_1.default.get(element, pathIDRef) === idTracker), Boolean));
        if (pathItemPossibilities === undefined) {
            return match;
        }
        for (const pathItem of pathItemPossibilities) {
            const item = lodash_1.default.get(match, pathItem);
            if (item !== undefined) {
                return item;
            }
        }
    }
    return undefined;
}
function getStatus(testResult) {
    const status = getRuleResultItem(testResult, RULE_RESULT_PATHS, ['idref'], ['cdf:result', 'result']);
    if (typeof status === 'string' && status === 'pass') {
        return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
    }
    else {
        return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
    }
}
function getStartTime(testResult) {
    const time = getRuleResultItem(testResult, RULE_RESULT_PATHS, ['idref'], ['time']);
    if (typeof time === 'string') {
        return time;
    }
    else {
        return '';
    }
}
function convertEncodedXmlIntoJson(encodedXml) {
    const xmlChunks = [];
    const htmlParser = new htmlparser.Parser({
        ontext(text) {
            xmlChunks.push(text);
        }
    });
    htmlParser.write(encodedXml);
    htmlParser.end();
    const xmlParsed = xmlChunks.join('');
    return fast_xml_parser_1.default.parse(xmlParsed);
}
function extractProfile(profile, pathProfileItemPossibilities) {
    const profileInfo = {
        id: '',
        description: '',
        title: ''
    };
    for (const profileKey of Object.keys(pathProfileItemPossibilities)) {
        for (const pathProfileItem of pathProfileItemPossibilities[profileKey]) {
            const item = lodash_1.default.get(profile, pathProfileItem);
            if (item) {
                if (profileKey === 'description') {
                    profileInfo[profileKey] =
                        convertEncodedXmlIntoJson(item);
                }
                else {
                    profileInfo[profileKey] = item;
                }
            }
        }
    }
    return profileInfo;
}
function getProfiles(profiles, pathSelectPossibilities, pathProfileItemPossibilities) {
    const profileInfos = [];
    for (const profile of profiles) {
        for (const pathSelect of pathSelectPossibilities) {
            const select = lodash_1.default.get(profile, pathSelect);
            if (select === undefined) {
                continue;
            }
            const selected = lodash_1.default.some(select, (element) => idTracker.replace('rule_SV', 'group_V').replace(/r\d+_rule/, '') ===
                lodash_1.default.get(element, 'idref') && lodash_1.default.get(element, 'selected') === 'true');
            if (selected) {
                profileInfos.push(extractProfile(profile, pathProfileItemPossibilities));
            }
        }
    }
    return profileInfos;
}
function extractCci(input) {
    let inputArray;
    if (Array.isArray(input)) {
        inputArray = input;
    }
    else {
        inputArray = [input];
    }
    const CCI_REGEX = /CCI-(\d*)/;
    const output = [];
    inputArray.forEach((element) => {
        const text = lodash_1.default.get(element, 'text');
        if (text.match(CCI_REGEX)) {
            output.push(text);
        }
    });
    return output;
}
function nistTag(input) {
    const identifiers = extractCci(input);
    return CCI_NIST_MAPPING.nistFilter(identifiers, DEFAULT_NIST_TAG, false);
}
class XCCDFResultsMapper extends base_converter_1.BaseConverter {
    constructor(scapXml) {
        super((0, base_converter_1.parseXml)(scapXml));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: {
                    path: ['cdf:Benchmark.cdf:platform.idref', 'Benchmark.platform.idref']
                }
            },
            version: package_json_1.version,
            statistics: {
                duration: 0
            },
            profiles: [
                {
                    name: { path: ['cdf:Benchmark.id', 'Benchmark.id'] },
                    version: { path: ['cdf:Benchmark.style', 'Benchmark.style'] },
                    title: { path: ['cdf:Benchmark.cdf:title', 'Benchmark.title.text'] },
                    maintainer: {
                        path: [
                            'cdf:Benchmark.cdf:reference.dc:publisher',
                            'Benchmark.reference.dc:publisher'
                        ]
                    },
                    summary: {
                        path: ['cdf:Benchmark.cdf:description', 'Benchmark.description.text']
                    },
                    description: {
                        path: ['cdf:Benchmark', 'Benchmark'],
                        transformer: (input) => {
                            const descriptionPaths = [
                                ['cdf:description', 'description'],
                                ['cdf:front-matter', 'front-matter'],
                                ['cdf:metadata', 'metadata'],
                                ['model'],
                                ['cdf:plain-text', 'plain-text'],
                                ['cdf:rear-matter', 'rear-matter'],
                                ['cdf:reference', 'reference'],
                                ['cdf:status', 'status'],
                                ['cdf:version', 'version'],
                                ['xml:lang'],
                                ['xmlns:cdf', 'xmlns'],
                                ['xmlns:dc'],
                                ['xmlns:dsi'],
                                ['xsi:schemaLocation'],
                                ['cdf:TestResult.cdf:benchmark', 'TestResult.benchmark'],
                                ['cdf:TestResult.start-time', 'TestResult.start-time'],
                                ['cdf:TestResult.end-time', 'TestResult.end-time'],
                                ['cdf:TestResult.id', 'TestResult.id'],
                                ['cdf:TestResult.cdf:identity', 'TestResult.identity'],
                                ['cdf:TestResult.cdf:organization'],
                                [
                                    'cdf:TestResult.cdf:platform.idref',
                                    'TestResult.platform.idref'
                                ],
                                ['cdf:TestResult.cdf:profile.idref', 'TestResult.profile.idref'],
                                ['cdf:TestResult.cdf:score', 'TestResult.score'],
                                ['cdf:TestResult.cdf:set-value', 'TestResult.set-value'],
                                ['cdf:TestResult.cdf:target', 'TestResult.target'],
                                [
                                    'cdf:TestResult.cdf:target-address',
                                    'TestResult.target-address'
                                ],
                                ['cdf:TestResult.cdf:target-facts', 'TestResult.target-facts'],
                                ['cdf:TestResult.cdf:target-id-ref'],
                                ['cdf:TestResult.test-system', 'TestResult.test-system'],
                                ['TestResult.title'],
                                ['cdf:TestResult.version', 'TestResult.version']
                            ];
                            const fullDescription = {};
                            for (const paths of descriptionPaths) {
                                for (const path of paths) {
                                    const item = lodash_1.default.get(input, path);
                                    if (item !== undefined) {
                                        fullDescription[path] = item;
                                    }
                                }
                            }
                            return JSON.stringify(fullDescription, null, 2);
                        }
                    },
                    license: { path: ['cdf:Benchmark.cdf:notice.id', 'Benchmark.notice.id'] },
                    copyright: {
                        path: [
                            'cdf:Benchmark.cdf:metadata.dc:creator',
                            'Benchmark.metadata.dc:creator.text'
                        ]
                    },
                    copyright_email: 'disa.stig_spt@mail.mil',
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: ['cdf:Benchmark.cdf:Group', 'Benchmark.Group'],
                            key: 'id',
                            id: {
                                path: ['cdf:Rule', 'Rule'],
                                transformer: (input) => {
                                    const valueIdPaths = [
                                        'cdf:check.cdf:check-export.value-id',
                                        'check.check-export.value-id'
                                    ];
                                    let setValueIdTracker = false;
                                    for (const path of valueIdPaths) {
                                        const valueId = lodash_1.default.get(input, path);
                                        if (valueId !== undefined) {
                                            valueIdTracker = valueId;
                                            setValueIdTracker = true;
                                        }
                                    }
                                    if (!setValueIdTracker) {
                                        valueIdTracker = undefined;
                                    }
                                    const id = lodash_1.default.get(input, 'id');
                                    if (typeof id === 'string') {
                                        idTracker = id;
                                        return id.split('_S')[1].split('r')[0];
                                    }
                                    else {
                                        return '';
                                    }
                                }
                            },
                            title: { path: ['cdf:Rule.cdf:title', 'Rule.title.text'] },
                            desc: {
                                path: ['cdf:Rule.cdf:description', 'Rule.description.text'],
                                transformer: (description) => {
                                    const descTextJson = convertEncodedXmlIntoJson(description);
                                    return lodash_1.default.get(descTextJson, 'VulnDiscussion', '');
                                }
                            },
                            descriptions: [
                                {
                                    data: {
                                        path: [
                                            'cdf:Rule.cdf:check.cdf:check-content-ref.name',
                                            'Rule.check.check-content-ref.name'
                                        ],
                                        transformer: base_converter_1.parseHtml
                                    },
                                    label: 'check'
                                },
                                {
                                    data: {
                                        path: ['cdf:Rule.cdf:fixtext.text', 'Rule.fixtext.text'],
                                        transformer: base_converter_1.parseHtml
                                    },
                                    label: 'fix'
                                }
                            ],
                            impact: {
                                path: ['cdf:Rule.severity', 'Rule.severity'],
                                transformer: (0, base_converter_1.impactMapping)(IMPACT_MAPPING)
                            },
                            refs: [],
                            tags: {
                                cci: {
                                    path: ['cdf:Rule.cdf:ident', 'Rule.ident'],
                                    transformer: extractCci
                                },
                                nist: {
                                    path: ['cdf:Rule.cdf:ident', 'Rule.ident'],
                                    transformer: nistTag
                                },
                                severity: { path: ['cdf:Rule.severity', 'Rule.severity'] },
                                description: {
                                    path: ['cdf:Rule.cdf:description', 'Rule.description.text'],
                                    transformer: convertEncodedXmlIntoJson
                                },
                                group_id: { path: 'id' },
                                group_title: { path: ['cdf:title', 'title.text'] },
                                group_description: {
                                    path: ['cdf:description', 'description.text'],
                                    transformer: convertEncodedXmlIntoJson
                                },
                                rule_id: { path: ['cdf:Rule.id', 'Rule.id'] },
                                check: { path: ['cdf:Rule.cdf:check', 'Rule.check'] },
                                fix_id: { path: ['cdf:Rule.cdf:fix.id', 'Rule.fix.id'] },
                                fixtext_fixref: {
                                    path: ['cdf:Rule.cdf:fixtext.fixref', 'Rule.fixtext.fixref']
                                },
                                ident: { path: ['cdf:Rule.cdf:ident', 'Rule.ident'] },
                                reference: { path: ['cdf:Rule.cdf:reference', 'Rule.reference'] },
                                selected: { path: 'Rule.selected' },
                                version: { path: ['cdf:Rule.id', 'Rule.version.text'] },
                                weight: { path: ['cdf:Rule.weight', 'Rule.weight'] },
                                profiles: {
                                    path: ['$.cdf:Benchmark.cdf:Profile', '$.Benchmark.Profile'],
                                    transformer: (profiles) => {
                                        const pathsSelect = ['cdf:select', 'select'];
                                        const paths = {
                                            id: ['id'],
                                            description: ['cdf:description', 'description.text'],
                                            title: ['cdf:title', 'title.text']
                                        };
                                        return getProfiles(profiles, pathsSelect, paths);
                                    }
                                },
                                rule_result: {
                                    path: [
                                        '$.cdf:Benchmark.cdf:TestResult',
                                        '$.Benchmark.TestResult'
                                    ],
                                    transformer: (testResult) => getRuleResultItem(testResult, RULE_RESULT_PATHS)
                                },
                                value: {
                                    path: ['$.cdf:Benchmark.cdf:Value', '$.Benchmark.Value'],
                                    transformer: (values) => {
                                        return lodash_1.default.find(values, (value) => {
                                            const id = lodash_1.default.get(value, 'id');
                                            return id && id === valueIdTracker;
                                        });
                                    }
                                }
                            },
                            code: '',
                            source_location: {},
                            results: [
                                {
                                    status: {
                                        path: [
                                            '$.cdf:Benchmark.cdf:TestResult',
                                            '$.Benchmark.TestResult'
                                        ],
                                        transformer: getStatus
                                    },
                                    code_desc: '',
                                    run_time: 0,
                                    start_time: {
                                        path: [
                                            '$.cdf:Benchmark.cdf:TestResult',
                                            '$.Benchmark.TestResult'
                                        ],
                                        transformer: getStartTime
                                    },
                                    message: '',
                                    resource: ''
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ]
        };
    }
}
exports.XCCDFResultsMapper = XCCDFResultsMapper;
//# sourceMappingURL=xccdf-results-mapper.js.map