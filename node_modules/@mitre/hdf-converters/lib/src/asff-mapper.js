"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASFFMapper = void 0;
const html_entities_1 = require("html-entities");
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const package_json_1 = require("../package.json");
const base_converter_1 = require("./base-converter");
const AwsConfigMapping_1 = require("./mappings/AwsConfigMapping");
const IMPACT_MAPPING = new Map([
    ['CRITICAL', 0.9],
    ['HIGH', 0.7],
    ['MEDIUM', 0.5],
    ['LOW', 0.3],
    ['INFORMATIONAL', 0.0]
]);
const DEFAULT_NIST_TAG = ['SA-11', 'RA-5'];
const SEVERITY_LABEL = 'Severity.Label';
const COMPLIANCE_STATUS = 'Compliance.Status';
const FROM_ASFF_TYPES_SLASH_REPLACEMENT = /{{{SLASH}}}/gi;
const FIREWALL_MANAGER_REGEX = /arn:.+:securityhub:.+:.*:product\/aws\/firewall-manager/;
const PROWLER_REGEX = /arn:.+:securityhub:.+:.*:product\/prowler\/prowler/;
const SECURITYHUB_REGEX = /arn:.+:securityhub:.+:.*:product\/aws\/securityhub/;
const TRIVY_REGEX = /arn:.+:securityhub:.+:.*:product\/aquasecurity\/aquasecurity/;
const PRODUCT_ARN_MAPPING = new Map([
    [FIREWALL_MANAGER_REGEX, getFirewallManager()],
    [PROWLER_REGEX, getProwler()],
    [SECURITYHUB_REGEX, getSecurityHub()],
    [TRIVY_REGEX, getTrivy()]
]);
function replaceTypesSlashes(data) {
    const findings = data.Findings.map((finding) => {
        var _a;
        return {
            ...finding,
            Types: (_a = finding.Types) === null || _a === void 0 ? void 0 : _a.map((type) => type.replace(FROM_ASFF_TYPES_SLASH_REPLACEMENT, '/'))
        };
    });
    return { Findings: findings };
}
function fixFileInput(asffJson) {
    try {
        let output = JSON.parse(asffJson);
        if (!lodash_1.default.has(output, 'Findings')) {
            if (Array.isArray(output)) {
                output = { Findings: output };
            }
            else {
                output = { Findings: [output] };
            }
        }
        return replaceTypesSlashes(output);
    }
    catch {
        const fixedInput = `[${asffJson
            .trim()
            .replace(/}\n/g, '},\n')
            .replace(/\},\n\$/g, '')}]`;
        let output = JSON.parse(fixedInput);
        if (!lodash_1.default.has(output, 'Findings')) {
            if (Array.isArray(output)) {
                output = { Findings: output };
            }
            else {
                output = { Findings: [output] };
            }
        }
        return replaceTypesSlashes(output);
    }
}
function getFirewallManager() {
    const findingId = (finding) => (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title'));
    const productName = (findings) => (0, html_entities_1.encode)(`${lodash_1.default.get(findings[0], 'ProductFields.aws/securityhub/CompanyName')} ${lodash_1.default.get(findings[0], 'ProductFields.aws/securityhub/ProductName')}`);
    return {
        findingId,
        productName
    };
}
function getProwler() {
    const subfindingsCodeDesc = (finding) => (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Description'));
    const findingId = (finding) => {
        const generatorId = lodash_1.default.get(finding, 'GeneratorId');
        const hyphenIndex = generatorId.indexOf('-');
        return (0, html_entities_1.encode)(generatorId.slice(hyphenIndex + 1));
    };
    const productName = (findings) => (0, html_entities_1.encode)(lodash_1.default.get(findings[0], 'ProductFields.ProviderName'));
    const desc = () => ' ';
    return {
        subfindingsCodeDesc,
        findingId,
        productName,
        desc
    };
}
function getSecurityHub() {
    const FINDING_STANDARDS_CONTROL_ARN = 'ProductFields.StandardsControlArn';
    const correspondingControl = (controls, finding) => {
        return controls.find((control) => lodash_1.default.get(control, 'StandardsControlArn') ===
            lodash_1.default.get(finding, FINDING_STANDARDS_CONTROL_ARN));
    };
    const supportingDocs = (standards) => {
        let controls;
        try {
            if (Array.isArray(standards)) {
                controls = standards
                    .map((standard) => lodash_1.default.get(JSON.parse(standard), 'Controls'))
                    .flat();
            }
            else {
                controls = null;
            }
        }
        catch (error) {
            throw new Error(`Invalid supporting docs for Security Hub:\nException: ${error}`);
        }
        const AWS_CONFIG_MAPPING = new AwsConfigMapping_1.AwsConfigMapping();
        return {
            controls,
            awsConfigMapping: AWS_CONFIG_MAPPING
        };
    };
    const findingId = (finding, { controls = null }) => {
        let output;
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            output = lodash_1.default.get(control, 'ControlId');
        }
        else if (lodash_1.default.has(finding, 'ProductFields.ControlId')) {
            output = lodash_1.default.get(finding, 'ProductFields.ControlId');
        }
        else if (lodash_1.default.has(finding, 'ProductFields.RuleId')) {
            output = lodash_1.default.get(finding, 'ProductFields.RuleId');
        }
        else {
            output = lodash_1.default.get(finding, 'GeneratorId').split('/').slice(-1)[0];
        }
        return (0, html_entities_1.encode)(output);
    };
    const findingImpact = (finding, { controls = null }) => {
        let impact;
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            impact = lodash_1.default.get(control, 'SeverityRating');
        }
        else {
            impact =
                lodash_1.default.get(finding, SEVERITY_LABEL) ||
                    lodash_1.default.get(finding, 'Severity.Normalized') / 100.0;
            if (typeof impact === 'string' && impact === 'INFORMATIONAL') {
                impact = 'MEDIUM';
            }
        }
        return impact;
    };
    const findingNistTag = (finding, { awsConfigMapping }) => {
        if (lodash_1.default.get(finding, 'ProductFields.RelatedAWSResources:0/type') !==
            'AWS::Config::ConfigRule') {
            return [];
        }
        return awsConfigMapping.searchNIST([
            lodash_1.default.get(finding, 'ProductFields.RelatedAWSResources:0/name')
        ]);
    };
    const findingTitle = (finding, { controls = null }) => {
        let control;
        if (controls !== null &&
            (control = correspondingControl(controls, finding)) !== null) {
            return (0, html_entities_1.encode)(lodash_1.default.get(control, 'Title'));
        }
        else {
            return (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title'));
        }
    };
    const productName = (findings) => {
        let standardName;
        if (lodash_1.default.get(findings[0], 'Types[0]')
            .split('/')
            .slice(-1)[0]
            .replace(/-/gi, ' ')
            .toLowerCase() ===
            lodash_1.default.get(findings[0], FINDING_STANDARDS_CONTROL_ARN)
                .split('/')
                .slice(-4)[0]
                .replace(/-/gi, ' ')
                .toLowerCase()) {
            standardName = lodash_1.default.get(findings[0], 'Types[0]')
                .split('/')
                .slice(-1)[0]
                .replace(/-/gi, ' ');
        }
        else {
            standardName = lodash_1.default.get(findings[0], FINDING_STANDARDS_CONTROL_ARN)
                .split('/')
                .slice(-4)[0]
                .replace(/-/gi, ' ')
                .split(/\s+/)
                .map((element) => {
                return element.charAt(0).toUpperCase() + element.slice(1);
            })
                .join(' ');
        }
        return (0, html_entities_1.encode)(`${standardName} v${lodash_1.default.get(findings[0], FINDING_STANDARDS_CONTROL_ARN)
            .split('/')
            .slice(-2)[0]}`);
    };
    return {
        supportingDocs,
        findingId,
        findingImpact,
        findingNistTag,
        findingTitle,
        productName
    };
}
function getTrivy() {
    const findingId = (finding) => {
        const generatorId = lodash_1.default.get(finding, 'GeneratorId');
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            return (0, html_entities_1.encode)(`${generatorId}/${cveId}`);
        }
        else {
            const id = lodash_1.default.get(finding, 'Id');
            return (0, html_entities_1.encode)(`${generatorId}/${id}`);
        }
    };
    const findingNistTag = (finding) => {
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            return ['SI-2', 'RA-5'];
        }
        else {
            return [];
        }
    };
    const subfindingsStatus = () => {
        return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
    };
    const subfindingsMessage = (finding) => {
        const cveId = lodash_1.default.get(finding, 'Resources[0].Details.Other.CVE ID');
        if (typeof cveId === 'string') {
            const patchedPackage = lodash_1.default.get(finding, 'Resources[0].Details.Other.Patched Package');
            const patchedVersionMessage = patchedPackage.length === 0
                ? 'There is no patched version of the package.'
                : `The package has been patched since version(s): ${patchedPackage}.`;
            return `For package ${lodash_1.default.get(finding, 'Resources[0].Details.Other.PkgName')}, the current version that is installed is ${lodash_1.default.get(finding, 'Resources[0].Details.Other.Installed Package')}.  ${patchedVersionMessage}`;
        }
        else {
            return undefined;
        }
    };
    return {
        findingId,
        findingNistTag,
        subfindingsStatus,
        subfindingsMessage
    };
}
class ASFFMapper extends base_converter_1.BaseConverter {
    constructor(asffJson, securityhubStandardsJsonArray = undefined, meta = null) {
        super(fixFileInput(asffJson));
        this.mappings = {
            platform: {
                name: 'Heimdall Tools',
                release: package_json_1.version,
                target_id: ''
            },
            version: package_json_1.version,
            statistics: {
                duration: null
            },
            profiles: [
                {
                    name: {
                        transformer: () => {
                            var _a;
                            return ((_a = this.meta) === null || _a === void 0 ? void 0 : _a.name) || 'AWS Security Finding Format';
                        }
                    },
                    version: '',
                    title: {
                        transformer: () => {
                            return lodash_1.default.get(this.meta, 'title') || 'ASFF Findings';
                        }
                    },
                    maintainer: null,
                    summary: '',
                    license: null,
                    copyright: null,
                    copyright_email: null,
                    supports: [],
                    attributes: [],
                    depends: [],
                    groups: [],
                    status: 'loaded',
                    controls: [
                        {
                            path: 'Findings',
                            key: 'id',
                            arrayTransformer: this.consolidate,
                            id: {
                                transformer: (finding) => this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'findingId', (0, html_entities_1.encode)(lodash_1.default.get(finding, 'GeneratorId')))
                            },
                            title: {
                                transformer: (finding) => this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'findingTitle', (0, html_entities_1.encode)(lodash_1.default.get(finding, 'Title')))
                            },
                            desc: {
                                path: 'Description',
                                transformer: (input) => (0, html_entities_1.encode)(input)
                            },
                            impact: {
                                transformer: (finding) => {
                                    let impact;
                                    if (lodash_1.default.get(finding, 'Workflow.Status') === 'SUPPRESSED') {
                                        impact = 'INFORMATIONAL';
                                    }
                                    else {
                                        const defaultFunc = () => lodash_1.default.get(finding, SEVERITY_LABEL)
                                            ? lodash_1.default.get(finding, SEVERITY_LABEL)
                                            : lodash_1.default.get(finding, 'Severity.Normalized') / 100.0;
                                        impact = this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'findingImpact', defaultFunc);
                                    }
                                    return typeof impact === 'string'
                                        ? IMPACT_MAPPING.get(impact) || 0
                                        : impact;
                                }
                            },
                            tags: {
                                nist: {
                                    transformer: (finding) => {
                                        const tags = this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'findingNistTag', []);
                                        if (tags.length === 0) {
                                            return DEFAULT_NIST_TAG;
                                        }
                                        else {
                                            return tags;
                                        }
                                    }
                                }
                            },
                            descriptions: [
                                {
                                    data: {
                                        path: 'Remediation.Recommendation',
                                        transformer: (input) => {
                                            const data = [];
                                            if (lodash_1.default.has(input, 'Text')) {
                                                data.push(lodash_1.default.get(input, 'Text'));
                                            }
                                            if (lodash_1.default.has(input, 'Url')) {
                                                data.push(lodash_1.default.get(input, 'Url'));
                                            }
                                            return data.join('\n');
                                        }
                                    },
                                    label: 'fix'
                                }
                            ],
                            refs: [
                                {
                                    url: {
                                        path: 'SourceUrl',
                                        transformer: (input) => !Boolean(input) ? undefined : input
                                    }
                                }
                            ],
                            source_location: {},
                            code: '',
                            results: [
                                {
                                    status: {
                                        transformer: (finding) => {
                                            const defaultFunc = () => {
                                                if (lodash_1.default.has(finding, COMPLIANCE_STATUS)) {
                                                    switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                        case 'PASSED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Passed;
                                                        case 'WARNING':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        case 'FAILED':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Failed;
                                                        case 'NOT_AVAILABLE':
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                        default:
                                                            return inspecjs_1.ExecJSON.ControlResultStatus.Error;
                                                    }
                                                }
                                                else {
                                                    return inspecjs_1.ExecJSON.ControlResultStatus.Skipped;
                                                }
                                            };
                                            return this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'subfindingsStatus', defaultFunc);
                                        }
                                    },
                                    code_desc: {
                                        transformer: (finding) => {
                                            let output = this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'subfindingsCodeDesc', '');
                                            if (output) {
                                                output += '; ';
                                            }
                                            const resources = lodash_1.default.get(finding, 'Resources')
                                                .map((resource) => {
                                                let hash = `Type: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Type'))}, Id: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Id'))}`;
                                                if (lodash_1.default.has(resource, 'Partition')) {
                                                    hash += `, Partition: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Partition'))}`;
                                                }
                                                if (lodash_1.default.has(resource, 'Region')) {
                                                    hash += `, Region: ${(0, html_entities_1.encode)(lodash_1.default.get(resource, 'Region'))}`;
                                                }
                                                return hash;
                                            })
                                                .join(', ');
                                            output += `Resources: [${resources}]`;
                                            return output;
                                        }
                                    },
                                    message: {
                                        transformer: (finding) => {
                                            const defaultFunc = () => {
                                                const statusReason = this.statusReason(finding);
                                                switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                    case undefined:
                                                        return undefined;
                                                    case 'PASSED':
                                                        return statusReason;
                                                    case 'WARNING':
                                                        return undefined;
                                                    case 'FAILED':
                                                        return statusReason;
                                                    case 'NOT_AVAILABLE':
                                                        return undefined;
                                                    default:
                                                        return statusReason;
                                                }
                                            };
                                            return this.externalProductHandler(lodash_1.default.get(finding, 'ProductArn'), finding, 'subfindingsMessage', defaultFunc);
                                        }
                                    },
                                    skip_message: {
                                        transformer: (finding) => {
                                            const statusReason = this.statusReason(finding);
                                            switch (lodash_1.default.get(finding, COMPLIANCE_STATUS)) {
                                                case undefined:
                                                    return statusReason;
                                                case 'PASSED':
                                                    return undefined;
                                                case 'WARNING':
                                                    return statusReason;
                                                case 'FAILED':
                                                    return undefined;
                                                case 'NOT_AVAILABLE':
                                                    return statusReason;
                                                default:
                                                    return undefined;
                                            }
                                        }
                                    },
                                    start_time: {
                                        transformer: (finding) => lodash_1.default.get(finding, 'LastObservedAt') ||
                                            lodash_1.default.get(finding, 'UpdatedAt')
                                    }
                                }
                            ]
                        }
                    ],
                    sha256: ''
                }
            ]
        };
        this.securityhubStandardsJsonArray = securityhubStandardsJsonArray;
        this.meta = meta;
        this.supportingDocs = new Map();
        const map = PRODUCT_ARN_MAPPING.get(SECURITYHUB_REGEX);
        if (map) {
            this.supportingDocs.set(SECURITYHUB_REGEX, lodash_1.default.get(map, 'supportingDocs')(this.securityhubStandardsJsonArray));
        }
    }
    statusReason(finding) {
        var _a;
        return (_a = lodash_1.default.get(finding, 'Compliance.StatusReasons')) === null || _a === void 0 ? void 0 : _a.map((reason) => Object.entries(reason).map(([key, value]) => {
            return `${(0, html_entities_1.encode)(key)}: ${(0, html_entities_1.encode)(value)}`;
        })).flat().join('\n');
    }
    externalProductHandler(product, data, func, defaultVal) {
        var _a;
        let arn = null;
        let mapping;
        if ((product instanceof RegExp ||
            (arn = Array.from(PRODUCT_ARN_MAPPING.keys()).find((regex) => regex.test(product)))) &&
            (mapping = PRODUCT_ARN_MAPPING.get(arn || product)) !==
                undefined &&
            func in mapping) {
            let keywords = {};
            if (this.supportingDocs.has(arn || product)) {
                keywords = { ...this.supportingDocs.get(arn || product) };
            }
            return (_a = lodash_1.default.get(PRODUCT_ARN_MAPPING.get(arn || product), func)) === null || _a === void 0 ? void 0 : _a.apply(this, [data, keywords]);
        }
        else {
            if (typeof defaultVal === 'function') {
                return defaultVal();
            }
            else {
                return defaultVal;
            }
        }
    }
    consolidate(input, file) {
        const allFindings = lodash_1.default.get(file, 'Findings');
        const productGroups = new Map();
        input.forEach((item, index) => {
            var _a, _b, _c, _d;
            let arn = Array.from(PRODUCT_ARN_MAPPING.keys()).find((regex) => lodash_1.default.get(allFindings[index], 'ProductArn').match(regex));
            if (!arn) {
                const productInfo = lodash_1.default.get(allFindings[index], 'ProductArn')
                    .split(':')
                    .slice(-1)[0];
                arn = new RegExp(`arn:.+:securityhub:.+:.*:product/${productInfo.split('/')[1]}/${productInfo.split('/')[2]}`);
            }
            if (!productGroups.has(arn)) {
                productGroups.set(arn, new Map());
            }
            if (!((_a = productGroups.get(arn)) === null || _a === void 0 ? void 0 : _a.has(lodash_1.default.get(item, 'id')))) {
                (_b = productGroups.get(arn)) === null || _b === void 0 ? void 0 : _b.set(lodash_1.default.get(item, 'id'), []);
            }
            (_d = (_c = productGroups
                .get(arn)) === null || _c === void 0 ? void 0 : _c.get(lodash_1.default.get(item, 'id'))) === null || _d === void 0 ? void 0 : _d.push([item, allFindings[index]]);
        });
        const output = [];
        productGroups.forEach((idGroups, product) => {
            idGroups.forEach((data, id) => {
                const group = data.map((d) => d[0]);
                const findings = data.map((d) => d[1]);
                const productInfo = lodash_1.default.get(findings[0], 'ProductArn')
                    .split(':')
                    .slice(-1)[0]
                    .split('/');
                const productName = this.externalProductHandler(product, findings, 'productName', (0, html_entities_1.encode)(`${productInfo[1]}/${productInfo[2]}`));
                const item = {
                    id: Array.from(new Map([...productGroups].filter(([pg]) => pg !== product)).values()).find((ig) => Array.from(ig.keys()).includes(id)) !== undefined
                        ? `[${productName}] ${id}`
                        : id,
                    title: `${productName}: ${lodash_1.default.uniq(group.map((d) => lodash_1.default.get(d, 'title'))).join(';')}`,
                    tags: {
                        nist: lodash_1.default.uniq(group.map((d) => lodash_1.default.get(d, 'tags.nist')).flat())
                    },
                    impact: Math.max(...group.map((d) => lodash_1.default.get(d, 'impact'))),
                    desc: this.externalProductHandler(product, group, 'desc', lodash_1.default.uniq(group.map((d) => lodash_1.default.get(d, 'desc'))).join('\n')),
                    descriptions: group
                        .map((d) => lodash_1.default.get(d, 'descriptions'))
                        .flat()
                        .filter((element, index, arr) => element.data !== '' &&
                        index === arr.findIndex((e) => e.data === element.data)),
                    refs: group
                        .map((d) => lodash_1.default.get(d, 'refs'))
                        .flat()
                        .filter((element) => lodash_1.default.get(element, 'url') !== undefined),
                    source_location: {},
                    code: JSON.stringify({ Findings: findings }, null, 2),
                    results: group
                        .map((d) => lodash_1.default.get(d, 'results'))
                        .flat()
                };
                output.push(item);
            });
        });
        return output;
    }
    setMappings(customMappings) {
        super.setMappings(customMappings);
    }
}
exports.ASFFMapper = ASFFMapper;
//# sourceMappingURL=asff-mapper.js.map