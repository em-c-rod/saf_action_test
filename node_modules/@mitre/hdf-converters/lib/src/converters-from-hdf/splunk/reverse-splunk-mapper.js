"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToSplunkMapper = exports.FromHDFControlToSplunkControlMapper = exports.FromHDFProfileToSplunkProfileMapper = exports.FromHDFExecutionToSplunkExecutionMapper = exports.createControlMapping = exports.createProfileMapping = exports.getProfileRunLevel = exports.getDependencies = exports.createReportMapping = exports.contextualizeIfNeeded = exports.createGUID = exports.MAPPER_NAME = exports.HDF_SPLUNK_SCHEMA = void 0;
const splunk_sdk_no_env_1 = __importDefault(require("@mitre/splunk-sdk-no-env"));
const inspecjs_1 = require("inspecjs");
const winston_1 = __importDefault(require("winston"));
const global_1 = require("../../utils/global");
const reverse_any_base_converter_1 = require("../reverse-any-base-converter");
exports.HDF_SPLUNK_SCHEMA = '1.1';
exports.MAPPER_NAME = 'HDF2Splunk';
let logger = winston_1.default.createLogger();
function createGUID(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
exports.createGUID = createGUID;
function contextualizeIfNeeded(data) {
    if ('contains' in data) {
        return data;
    }
    else {
        return (0, inspecjs_1.contextualizeEvaluation)(data);
    }
}
exports.contextualizeIfNeeded = contextualizeIfNeeded;
function createReportMapping(execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            filename: filename,
            subtype: 'header',
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation'
        },
        profiles: [],
        platform: execution.data.platform,
        statistics: execution.data.statistics,
        version: execution.data.version
    };
}
exports.createReportMapping = createReportMapping;
function getDependencies(profile, execution) {
    var _a;
    if (profile && execution) {
        const dependencies = [];
        (_a = profile.data.depends) === null || _a === void 0 ? void 0 : _a.forEach((dependency) => {
            if (dependency.name) {
                dependencies.push(dependency.name);
                dependencies.push(...getDependencies(execution.contains.find((execProfile) => execProfile.data.name === dependency.name), execution));
            }
        });
        return dependencies;
    }
    return [];
}
exports.getDependencies = getDependencies;
function getProfileRunLevel(profile, execution) {
    return getDependencies(profile, execution).length;
}
exports.getProfileRunLevel = getProfileRunLevel;
function createProfileMapping(filename, guid) {
    return {
        meta: {
            filename: filename,
            filetype: 'evaluation',
            guid: guid,
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            is_baseline: {
                path: 'data.depends[0].name',
                transformer: (value) => {
                    return !Boolean(value);
                }
            },
            profile_sha256: {
                path: 'data.sha256'
            },
            subtype: 'profile'
        },
        summary: {
            path: 'data.summary'
        },
        name: {
            path: 'data.name'
        },
        sha256: {
            path: 'data.sha256'
        },
        supports: {
            path: 'data.supports'
        },
        copyright: {
            path: 'data.copyright'
        },
        copyright_email: {
            path: 'data.copyright_email'
        },
        maintainer: {
            path: 'data.maintainer'
        },
        version: {
            path: 'data.version'
        },
        license: {
            path: 'data.license'
        },
        title: {
            path: 'data.title'
        },
        controls: [],
        parent_profile: {
            path: 'data.parent_profile',
            default: undefined
        },
        depends: {
            path: 'data.depends',
            default: []
        },
        attributes: {
            path: 'data.attributes'
        },
        groups: {
            path: 'data.groups'
        },
        status: {
            path: 'data.status'
        }
    };
}
exports.createProfileMapping = createProfileMapping;
function createControlMapping(control, profile, execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            status: control.hdf.status,
            profile_sha256: profile.data.sha256,
            filename: filename,
            subtype: 'control',
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation',
            is_baseline: getProfileRunLevel(profile, execution) === 0,
            is_waived: control.hdf.waived,
            overlay_depth: getProfileRunLevel(profile, execution) + 1
        },
        title: control.data.title,
        code: control.data.code || '',
        desc: control.data.desc || '',
        descriptions: {
            path: 'data.descriptions',
            transformer: (data) => {
                const descObjects = {};
                if (Array.isArray(data)) {
                    data.forEach((item) => {
                        descObjects[item['label']] = item['data'];
                    });
                }
                return descObjects;
            }
        },
        id: control.data.id,
        impact: control.data.impact,
        refs: control.data.refs || [],
        source_location: control.data.source_location,
        tags: control.data.tags,
        results: control.hdf.segments
    };
}
exports.createControlMapping = createControlMapping;
class FromHDFExecutionToSplunkExecutionMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(evaluation, filename, guid) {
        super(evaluation);
        this.setMappings(createReportMapping(evaluation, filename, guid));
    }
    toSplunkExecution() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFExecutionToSplunkExecutionMapper = FromHDFExecutionToSplunkExecutionMapper;
class FromHDFProfileToSplunkProfileMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(profile, filename, guid) {
        super(profile);
        this.setMappings(createProfileMapping(filename, guid));
    }
    toSplunkProfile() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFProfileToSplunkProfileMapper = FromHDFProfileToSplunkProfileMapper;
class FromHDFControlToSplunkControlMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(control, profile, execution, filename, guid) {
        super(control);
        this.setMappings(createControlMapping(control, profile, execution, filename, guid));
    }
    toSplunkControl() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFControlToSplunkControlMapper = FromHDFControlToSplunkControlMapper;
class FromHDFToSplunkMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(data, logService, loggingLevel) {
        if (logService) {
            logger = logService;
        }
        else {
            logger = (0, global_1.createWinstonLogger)(exports.MAPPER_NAME, loggingLevel || 'debug');
        }
        super(contextualizeIfNeeded(data));
    }
    createSplunkData(guid, filename) {
        const splunkData = {
            controls: [],
            profiles: [],
            reports: []
        };
        splunkData.reports.push(new FromHDFExecutionToSplunkExecutionMapper(this.data, filename, guid).toSplunkExecution());
        this.data.contains.forEach((profile) => {
            splunkData.profiles.push(new FromHDFProfileToSplunkProfileMapper(profile, filename, guid).toSplunkProfile());
            profile.contains.forEach((control) => {
                splunkData.controls.push(new FromHDFControlToSplunkControlMapper(control, profile, this.data, filename, guid).toSplunkControl());
            });
        });
        return splunkData;
    }
    uploadSplunkData(targetIndex, splunkData) {
        splunkData.reports.forEach((report) => {
            targetIndex.submitEvent(JSON.stringify(report), {
                sourcetype: exports.MAPPER_NAME,
                index: targetIndex.name
            }, (err) => {
                if (err) {
                    console.error(err);
                    throw err;
                }
                logger.verbose(`Successfully uploaded execution for ${report.meta.filename}`);
            });
        });
        targetIndex.submitEvent(splunkData.profiles.map((profile) => JSON.stringify(profile)).join('\n'), {
            sourcetype: exports.MAPPER_NAME,
            index: targetIndex.name
        }, (err) => {
            if (err) {
                console.error(err);
                throw err;
            }
            logger.verbose(`Successfully uploaded ${splunkData.profiles.length} profile layer(s)`);
        });
        targetIndex.submitEvent(splunkData.controls.map((control) => JSON.stringify(control)).join('\n'), {
            sourcetype: exports.MAPPER_NAME,
            index: targetIndex.name
        }, (err) => {
            if (err) {
                console.error(err);
                throw err;
            }
            logger.verbose(`Successfully uploaded ${splunkData.controls.length} control(s)`);
        });
    }
    toSplunk(config, filename) {
        const service = new splunk_sdk_no_env_1.default.Service(config);
        if (!config.insecure) {
            service.requestOptions.strictSSL = true;
        }
        else {
            logger.info(`SSL Verification Disabled`);
        }
        logger.info(`Logging into Splunk Service: ${config.host} with user ${config.username}`);
        logger.verbose('Got Execution: ' + filename);
        const guid = createGUID(30);
        logger.verbose('Using GUID: ' + guid);
        service.login((err, success) => {
            if (err) {
                throw err;
            }
            logger.info('Login was successful: ' + success);
            service.indexes().fetch((error, indexes) => {
                if (error) {
                    logger.error(error);
                    throw error;
                }
                const availableIndexes = indexes
                    .list()
                    .map((index) => index.name);
                logger.verbose(`Available Indexes:  + ${availableIndexes.join(', ')}`);
                if (availableIndexes.includes(config.index)) {
                    const targetIndex = indexes.item(config.index);
                    const splunkData = this.createSplunkData(guid, filename);
                    this.uploadSplunkData(targetIndex, splunkData);
                    logger === null || logger === void 0 ? void 0 : logger.verbose(`Have index ${targetIndex.name}`);
                }
                else {
                    logger.error(`Invalid Index: ${config.index}`);
                    throw new Error(`Invalid Index: ${config.index}`);
                }
            });
        });
        return guid;
    }
}
exports.FromHDFToSplunkMapper = FromHDFToSplunkMapper;
//# sourceMappingURL=reverse-splunk-mapper.js.map