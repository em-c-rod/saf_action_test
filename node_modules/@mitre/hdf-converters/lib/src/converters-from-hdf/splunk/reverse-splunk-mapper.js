"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FromHDFToSplunkMapper = exports.FromHDFControlToSplunkControlMapper = exports.FromHDFProfileToSplunkProfileMapper = exports.FromHDFExecutionToSplunkExecutionMapper = exports.createControlMapping = exports.createProfileMapping = exports.getProfileRunLevel = exports.getDependencies = exports.createReportMapping = exports.postDataToSplunkHEC = exports.contextualizeIfNeeded = exports.createGUID = exports.HDF_SPLUNK_SCHEMA = void 0;
const axios_1 = __importDefault(require("axios"));
const inspecjs_1 = require("inspecjs");
const reverse_any_base_converter_1 = require("../reverse-any-base-converter");
exports.HDF_SPLUNK_SCHEMA = '1.0';
function createGUID(length) {
    let result = '';
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    const charactersLength = characters.length;
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}
exports.createGUID = createGUID;
function contextualizeIfNeeded(data) {
    if ('contains' in data) {
        return data;
    }
    else {
        return (0, inspecjs_1.contextualizeEvaluation)(data);
    }
}
exports.contextualizeIfNeeded = contextualizeIfNeeded;
function postDataToSplunkHEC(data, config) {
    if (Array.isArray(data)) {
        return data.map((item) => axios_1.default.post(`${config.protocol}://${config.host}:${config.port}/services/collector`, {
            event: item,
            index: config.index
        }, {
            headers: {
                Authorization: `Splunk ${config.token}`
            }
        }));
    }
    else {
        return [
            axios_1.default.post(`${config.protocol}://${config.host}:${config.port}/services/collector`, {
                event: data
            }, {
                headers: {
                    Authorization: `Splunk ${config.token}`
                }
            })
        ];
    }
}
exports.postDataToSplunkHEC = postDataToSplunkHEC;
function createReportMapping(execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            filename: filename,
            subtype: 'header',
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation'
        },
        platform: execution.data.platform,
        statistics: execution.data.statistics,
        version: execution.data.version
    };
}
exports.createReportMapping = createReportMapping;
function getDependencies(profile, execution) {
    var _a;
    if (profile && execution) {
        const dependencies = [];
        (_a = profile.data.depends) === null || _a === void 0 ? void 0 : _a.forEach((dependency) => {
            if (dependency.name) {
                dependencies.push(dependency.name);
                dependencies.push(...getDependencies(execution.contains.find((execProfile) => execProfile.data.name === dependency.name), execution));
            }
        });
        return dependencies;
    }
    return [];
}
exports.getDependencies = getDependencies;
function getProfileRunLevel(profile, execution) {
    return getDependencies(profile, execution).length;
}
exports.getProfileRunLevel = getProfileRunLevel;
function createProfileMapping(filename, guid) {
    return {
        meta: {
            filename: filename,
            filetype: 'evaluation',
            guid: guid,
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            is_baseline: {
                path: 'data.depends[0].name',
                transformer: (value) => {
                    return !Boolean(value);
                }
            },
            profile_sha256: {
                path: 'data.sha256'
            },
            subtype: 'header'
        },
        summary: {
            path: 'data.summary'
        },
        name: {
            path: 'data.name'
        },
        sha256: {
            path: 'data.sha256'
        },
        supports: {
            path: 'data.supports'
        },
        copyright: {
            path: 'data.copyright'
        },
        copyright_email: {
            path: 'data.copyright_email'
        },
        maintainer: {
            path: 'data.maintainer'
        },
        version: {
            path: 'data.version'
        },
        license: {
            path: 'data.license'
        },
        title: {
            path: 'data.title'
        },
        parent_profile: {
            path: 'data.depends[0].name'
        },
        depends: {
            path: 'data.depends'
        },
        attributes: {
            path: 'data.attributes'
        },
        groups: {
            path: 'data.groups'
        },
        status: {
            path: 'data.status'
        }
    };
}
exports.createProfileMapping = createProfileMapping;
function createControlMapping(control, profile, execution, filename, guid) {
    return {
        meta: {
            guid: guid,
            status: control.hdf.status,
            profile_sha256: profile.data.sha256,
            filename: filename,
            subtype: 'control',
            hdf_splunk_schema: exports.HDF_SPLUNK_SCHEMA,
            filetype: 'evaluation',
            is_baseline: getProfileRunLevel(profile, execution) === 0,
            is_waived: control.hdf.waived,
            overlay_depth: getProfileRunLevel(profile, execution) + 1
        },
        code: control.data.code || '',
        desc: control.data.desc || '',
        descriptions: {
            path: 'data.descriptions',
            transformer: (data) => {
                const descObjects = {};
                data.forEach((item) => {
                    descObjects[item['label']] = item['data'];
                });
                return descObjects;
            }
        },
        id: control.data.id,
        impact: control.data.impact,
        refs: control.data.refs || [],
        source_location: control.data.source_location,
        tags: control.data.tags,
        results: control.hdf.segments
    };
}
exports.createControlMapping = createControlMapping;
class FromHDFExecutionToSplunkExecutionMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(evaluation, filename, guid) {
        super(evaluation);
        this.setMappings(createReportMapping(evaluation, filename, guid));
    }
    toSplunkExecution() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFExecutionToSplunkExecutionMapper = FromHDFExecutionToSplunkExecutionMapper;
class FromHDFProfileToSplunkProfileMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(profile, filename, guid) {
        super(profile);
        this.setMappings(createProfileMapping(filename, guid));
    }
    toSplunkProfile() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFProfileToSplunkProfileMapper = FromHDFProfileToSplunkProfileMapper;
class FromHDFControlToSplunkControlMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(control, profile, execution, filename, guid) {
        super(control);
        this.setMappings(createControlMapping(control, profile, execution, filename, guid));
    }
    toSplunkControl() {
        return this.convertInternal(this.data, this.mappings);
    }
}
exports.FromHDFControlToSplunkControlMapper = FromHDFControlToSplunkControlMapper;
class FromHDFToSplunkMapper extends reverse_any_base_converter_1.FromAnyBaseConverter {
    constructor(data) {
        super(contextualizeIfNeeded(data));
    }
    async toSplunk(config, filename) {
        const splunkData = {
            controls: [],
            profiles: [],
            reports: []
        };
        const guid = createGUID(30);
        splunkData.reports.push(new FromHDFExecutionToSplunkExecutionMapper(this.data, filename, guid).toSplunkExecution());
        this.data.contains.forEach((profile) => {
            splunkData.profiles.push(new FromHDFProfileToSplunkProfileMapper(profile, filename, guid).toSplunkProfile());
            profile.contains.forEach((control) => {
                splunkData.controls.push(new FromHDFControlToSplunkControlMapper(control, profile, this.data, filename, guid).toSplunkControl());
            });
        });
        const uploads = [];
        uploads.push(...postDataToSplunkHEC(splunkData.reports, config));
        uploads.push(...postDataToSplunkHEC(splunkData.profiles, config));
        uploads.push(...postDataToSplunkHEC(splunkData.controls, config));
        return Promise.all(uploads).then(() => guid);
    }
}
exports.FromHDFToSplunkMapper = FromHDFToSplunkMapper;
//# sourceMappingURL=reverse-splunk-mapper.js.map