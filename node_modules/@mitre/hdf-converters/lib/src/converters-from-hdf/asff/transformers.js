"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupControlStatus = exports.setupDetailsAssume = exports.setupResourcesID2 = exports.setupResourcesID = exports.setupProdFieldCheck = exports.setupRemRec = exports.getFixForControl = exports.setupFindingType = exports.setupSevOriginal = exports.setupSevLabel = exports.setupDescr = exports.setupTitle = exports.setupGeneratorId = exports.setupUpdated = exports.setupRegion = exports.setupCreated = exports.setupAwsAcct = exports.setupProductARN = exports.setupId = exports.createCode = exports.createNote = exports.getAllLayers = exports.cleanText = exports.sliceIntoChunks = exports.createAssumeRolePolicyDocument = exports.createDescription = exports.statusCount = exports.createProfileInfoFinding = exports.getRunTime = exports.escapeForwardSlashes = void 0;
const crypto_1 = require("crypto");
const inspecjs_1 = require("inspecjs");
const lodash_1 = __importDefault(require("lodash"));
const moment_1 = __importDefault(require("moment"));
const package_json_1 = require("../../../package.json");
const global_1 = require("../../utils/global");
const reverse_asff_mapper_1 = require("./reverse-asff-mapper");
function escapeForwardSlashes(s) {
    return s.replace(/\//g, reverse_asff_mapper_1.TO_ASFF_TYPES_SLASH_REPLACEMENT);
}
exports.escapeForwardSlashes = escapeForwardSlashes;
function getRunTime(hdf) {
    let time = new Date().toISOString();
    hdf.profiles.forEach((profile) => {
        if (profile.controls[0] &&
            profile.controls[0].results.length &&
            profile.controls[0].results[0].start_time) {
            try {
                time = new Date(profile.controls[0].results[0].start_time).toISOString();
            }
            catch {
                time = new Date().toISOString();
            }
        }
    });
    return time;
}
exports.getRunTime = getRunTime;
function filter_overlays(controls) {
    const idHash = {};
    controls.forEach((c) => {
        const id = c.hdf.wraps.id;
        const old = idHash[id];
        if (old) {
            const newSignificant = c.hdf.status_list && c.hdf.status_list.length > 0;
            if (newSignificant) {
                idHash[id] = c;
            }
        }
        else {
            idHash[id] = c;
        }
    });
    return Array.from(Object.values(idHash));
}
function createProfileInfoFinding(hdf, options) {
    const runTime = getRunTime(hdf);
    const inspecJSJson = (0, inspecjs_1.convertFile)(JSON.stringify(hdf));
    const contextualizedEvaluation = (0, inspecjs_1.contextualizeEvaluation)(inspecJSJson['1_0_ExecJson']);
    const counts = statusCount(contextualizedEvaluation);
    const updatedAt = new Date();
    updatedAt.setMilliseconds(updatedAt.getMilliseconds() +
        (contextualizedEvaluation.contains[0].contains.length || 0));
    const profileInfo = {
        SchemaVersion: '2018-10-08',
        Id: `${options.target}/${hdf.profiles[0].name}`,
        ProductArn: `arn:aws:securityhub:${options.region}:${options.awsAccountId}:product/${options.awsAccountId}/default`,
        GeneratorId: `arn:aws:securityhub:us-east-2:${options.awsAccountId}:ruleset/set/${hdf.profiles[0].name}`,
        AwsAccountId: options.awsAccountId,
        CreatedAt: runTime,
        UpdatedAt: updatedAt,
        Title: `${options.target} | ${hdf.profiles[0].name} | ${(0, moment_1.default)().format('YYYY-MM-DD hh:mm:ss [GMT]ZZ')}`,
        Description: createDescription(counts),
        Severity: {
            Label: 'INFORMATIONAL'
        },
        FindingProviderFields: {
            Severity: {
                Label: 'INFORMATIONAL'
            },
            Types: createProfileInfoFindingFields(hdf)
        },
        Resources: [
            {
                Type: 'AwsAccount',
                Id: `AWS::::Account:${options.awsAccountId}`,
                Partition: 'aws',
                Region: options.region
            }
        ]
    };
    return profileInfo;
}
exports.createProfileInfoFinding = createProfileInfoFinding;
function statusCount(evaluation) {
    let controls = [];
    evaluation.contains.forEach((p) => controls.push(...p.contains));
    controls = filter_overlays(controls);
    const statusCounts = {
        Passed: 0,
        PassedTests: 0,
        PassingTestsFailedControl: 0,
        Failed: 0,
        FailedTests: 0,
        NotApplicable: 0,
        NotReviewed: 0
    };
    controls.forEach((control) => {
        if (control.hdf.status === 'Passed') {
            statusCounts.Passed += 1;
            statusCounts.PassedTests += (control.hdf.segments || []).length;
        }
        else if (control.hdf.status === 'Failed') {
            statusCounts.PassingTestsFailedControl += (control.hdf.segments || []).filter((s) => s.status === 'passed').length;
            statusCounts.FailedTests += (control.hdf.segments || []).filter((s) => s.status === 'failed').length;
            statusCounts.Failed += 1;
        }
        else if (control.hdf.status === 'Not Applicable') {
            statusCounts.NotApplicable += 1;
        }
        else if (control.hdf.status === 'Not Reviewed') {
            statusCounts.NotReviewed += 1;
        }
    });
    return statusCounts;
}
exports.statusCount = statusCount;
function createDescription(counts) {
    return `Passed: ${counts.Passed} (${counts.PassedTests} individual checks passed) --- Failed: ${counts.Failed} (${counts.PassingTestsFailedControl} individual checks failed out of ${counts.PassingTestsFailedControl + counts.FailedTests} total checks) --- Not Applicable: ${counts.NotApplicable} (System exception or absent component) --- Not Reviewed: ${counts.NotReviewed} (Can only be tested manually at this time)`;
}
exports.createDescription = createDescription;
function createAssumeRolePolicyDocument(layersOfControl, segment) {
    const segmentOverview = createNote(segment);
    const code = layersOfControl.map((layer) => createCode(layer)).join('\n\n');
    return `${code}\n\n${segmentOverview}`;
}
exports.createAssumeRolePolicyDocument = createAssumeRolePolicyDocument;
function sliceIntoChunks(arr, chunkSize) {
    const res = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        res.push(chunk);
    }
    return res;
}
exports.sliceIntoChunks = sliceIntoChunks;
function cleanText(text) {
    if (text) {
        return text.replace(/  +/g, ' ').replace(/\r?\n|\r/g, ' ');
    }
    else {
        return undefined;
    }
}
exports.cleanText = cleanText;
function getAllLayers(hdf, knownControl) {
    if (hdf.profiles.length === 1) {
        return [
            {
                ...knownControl,
                profileInfo: {
                    ...lodash_1.default.omit(hdf.profiles[0], 'controls')
                }
            }
        ];
    }
    else {
        const foundControls = [];
        hdf.profiles.forEach((profile) => {
            profile.controls.forEach((control) => {
                if (control.id === knownControl.id) {
                    foundControls.push({
                        ...control,
                        profileInfo: { ...lodash_1.default.omit(profile, 'controls') }
                    });
                }
            });
        });
        return foundControls;
    }
}
exports.getAllLayers = getAllLayers;
function createNote(segment) {
    if (segment.message) {
        return `Test Description: ${segment.code_desc} --- Test Result: ${segment.message}`;
    }
    else if (segment.skip_message) {
        return `Test Description: ${segment.code_desc} --- Skip Message: ${segment.skip_message}`;
    }
    else {
        return `Test Description: ${segment.code_desc}`;
    }
}
exports.createNote = createNote;
function cleanObjectValues(value) {
    if (Array.isArray(value)) {
        return value.length < 0;
    }
    return !Boolean(value);
}
function createCode(control) {
    var _a, _b;
    return `=========================================================\n# Profile name: ${(_a = control.profileInfo) === null || _a === void 0 ? void 0 : _a.name}\n=========================================================\n\n${control.code
        ? (_b = control.code) === null || _b === void 0 ? void 0 : _b.replace(/\\\"/g, '"')
        : JSON.stringify(lodash_1.default.omitBy(lodash_1.default.omit(control, 'results'), cleanObjectValues))}`;
}
exports.createCode = createCode;
function setupId(control, context) {
    const target = context === null || context === void 0 ? void 0 : context.ioptions.target;
    const name = context === null || context === void 0 ? void 0 : context.data.profiles[0].name;
    return `${target}/${name}/${control.id}/finding/${(0, crypto_1.createHash)('sha256')
        .update(control.id + control.result.code_desc)
        .digest('hex')}`;
}
exports.setupId = setupId;
function setupProductARN(_val, context) {
    return `arn:aws:securityhub:${context === null || context === void 0 ? void 0 : context.ioptions.region}:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}:product/${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}/default`;
}
exports.setupProductARN = setupProductARN;
function setupAwsAcct(_val, context) {
    return context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId;
}
exports.setupAwsAcct = setupAwsAcct;
function setupCreated(control) {
    return control.result.start_time || new Date().toISOString();
}
exports.setupCreated = setupCreated;
function setupRegion(_val, context) {
    return context === null || context === void 0 ? void 0 : context.ioptions.region;
}
exports.setupRegion = setupRegion;
function setupUpdated(_control, context) {
    const time = new Date();
    time.setMilliseconds(time.getMilliseconds() + ((context === null || context === void 0 ? void 0 : context.index) || 0));
    return time.toISOString();
}
exports.setupUpdated = setupUpdated;
function setupGeneratorId(control, context) {
    return `arn:aws:securityhub:${context === null || context === void 0 ? void 0 : context.ioptions.region}:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}:ruleset/set/${context === null || context === void 0 ? void 0 : context.data.profiles[0].name}/rule/${control.id}`;
}
exports.setupGeneratorId = setupGeneratorId;
function setupTitle(control) {
    const nistTags = control.tags.nist ? `[${control.tags.nist.join(', ')}]` : '';
    return lodash_1.default.truncate(`${control.id} | ${nistTags} | ${cleanText(control.title)}`, { length: 256 });
}
exports.setupTitle = setupTitle;
function setupDescr(control) {
    const checkText = (0, global_1.getDescription)(control.descriptions || [], 'check') ||
        control.tags.check ||
        'Check not available';
    const currentVal = lodash_1.default.truncate(cleanText(`${control.desc} -- Check Text: ${checkText}`), { length: 1024, omission: '[SEE FULL TEXT IN AssumeRolePolicyDocument]' });
    const caveat = (0, global_1.getDescription)(control.descriptions || [], 'caveat');
    if (caveat) {
        return lodash_1.default.truncate(`Caveat: ${cleanText(caveat)} --- Description: ${currentVal}`, { length: 1024, omission: '' });
    }
    return currentVal;
}
exports.setupDescr = setupDescr;
function setupSevLabel(control, context) {
    return (context === null || context === void 0 ? void 0 : context.impactMapping.get(control.impact)) || 'INFORMATIONAL';
}
exports.setupSevLabel = setupSevLabel;
function setupSevOriginal(control) {
    return `${control.impact}`;
}
exports.setupSevOriginal = setupSevOriginal;
function createControlMetadata(control) {
    const types = [
        `Control/ID/${control.id}`,
        `Control/Impact/${control.impact}`
    ];
    if (control.title) {
        types.push(`Control/Title/${escapeForwardSlashes(control.title)}`);
    }
    return types;
}
function createProfileInfo(hdf) {
    const typesArr = [];
    const targets = [
        'name',
        'version',
        'sha256',
        'title',
        'maintainer',
        'summary',
        'license',
        'copyright',
        'copyright_email'
    ];
    hdf === null || hdf === void 0 ? void 0 : hdf.profiles.forEach((layer) => {
        const profileInfos = [];
        targets.forEach((target) => {
            const value = lodash_1.default.get(layer, target);
            if (typeof value === 'string') {
                profileInfos.push({ [target]: value });
            }
        });
        typesArr.push(`Profile/Info/${escapeForwardSlashes(JSON.stringify(profileInfos))}`);
    });
    return typesArr;
}
function createProfileInfoFindingFields(hdf) {
    let typesArr = [`MITRE/SAF/${package_json_1.version}-hdf2asff`];
    const executionTargets = ['platform', 'statistics', 'version', 'passthrough'];
    executionTargets.forEach((target) => {
        const value = lodash_1.default.get(hdf, target);
        if (typeof value === 'string') {
            typesArr.push(`Execution/${escapeForwardSlashes(target)}/${escapeForwardSlashes(value)}`);
        }
        else if (typeof value === 'object') {
            typesArr.push(`Execution/${escapeForwardSlashes(target)}/${escapeForwardSlashes(JSON.stringify(value))}`);
        }
    });
    hdf.profiles.forEach((profile) => {
        const targets = [
            'version',
            'sha256',
            'maintainer',
            'summary',
            'license',
            'copyright',
            'copyright_email',
            'name',
            'title',
            'depends'
        ];
        targets.forEach((target) => {
            const value = lodash_1.default.get(profile, target);
            if (typeof value === 'string') {
                typesArr.push(`${escapeForwardSlashes(profile.name)}/${escapeForwardSlashes(target)}/${escapeForwardSlashes(value)}`);
            }
            else if (typeof value === 'object') {
                typesArr.push(`${escapeForwardSlashes(profile.name)}/${escapeForwardSlashes(target)}/${escapeForwardSlashes(JSON.stringify(value))}`);
            }
        });
        const inputs = [];
        profile.attributes.forEach((input) => {
            if (input.options.value) {
                inputs.push({ [input.name]: input.options.value });
            }
        });
        typesArr.push(`${escapeForwardSlashes(profile.name)}/inputs/${escapeForwardSlashes(JSON.stringify(inputs))}`);
    });
    typesArr = typesArr.slice(0, 50);
    return typesArr;
}
function createSegmentInfo(segment) {
    const typesArr = [];
    const targets = [
        'code_desc',
        'exception',
        'message',
        'resource',
        'run_time',
        'start_time',
        'skip_message',
        'status'
    ];
    targets.forEach((target) => {
        const value = lodash_1.default.get(segment, target);
        if (typeof value === 'string' && value) {
            typesArr.push(`Segment/${escapeForwardSlashes(target)}/${escapeForwardSlashes(value)}`);
        }
    });
    return typesArr;
}
function createTagInfo(control) {
    const typesArr = [];
    for (const tag in control.tags) {
        if (control) {
            if (typeof control.tags[tag] === 'string') {
                typesArr.push(`Tags/${escapeForwardSlashes(tag)}/${control.tags[tag].length > 0
                    ? escapeForwardSlashes(control.tags[tag])
                    : '""'}`);
            }
            else if (Array.isArray(control.tags[tag])) {
                const classifier = control.tags[tag].length > 0
                    ? `[${escapeForwardSlashes(control.tags[tag].join(', '))}]`
                    : '[]';
                typesArr.push(`Tags/${escapeForwardSlashes(tag)}/${classifier}`);
            }
        }
    }
    return typesArr;
}
function createDescriptionInfo(control) {
    var _a;
    const typesArr = [];
    if (Array.isArray(control.descriptions)) {
        (_a = control.descriptions) === null || _a === void 0 ? void 0 : _a.forEach((description) => {
            typesArr.push(`Descriptions/${escapeForwardSlashes(description.label)}/${escapeForwardSlashes(cleanText(description.data) || 'No Value')}`);
        });
    }
    else {
        Object.entries(control.descriptions || {}).forEach(([key, value]) => {
            typesArr.push(`Descriptions/${escapeForwardSlashes(key)}/${escapeForwardSlashes(cleanText(value) || 'No Value')}`);
        });
    }
    return typesArr;
}
function setupFindingType(control, context) {
    const slashSplit = context === null || context === void 0 ? void 0 : context.ioptions.input.split('\\')[(context === null || context === void 0 ? void 0 : context.ioptions.input.split('\\').length) - 1];
    const filename = slashSplit === null || slashSplit === void 0 ? void 0 : slashSplit.split('/')[slashSplit.split('/').length - 1];
    const typesArr = [
        `MITRE/SAF/${package_json_1.version}-hdf2asff`,
        `File/Input/${filename}`,
        `Control/Code/${escapeForwardSlashes(control.layersOfControl
            .map((layer) => createCode(layer))
            .join('\n\n'))}`
    ];
    typesArr.push(...createControlMetadata(control));
    typesArr.push(...createProfileInfo(context === null || context === void 0 ? void 0 : context.data));
    typesArr.push(...createSegmentInfo(control.result));
    typesArr.push(...createTagInfo(control));
    typesArr.push(...createDescriptionInfo(control));
    return typesArr;
}
exports.setupFindingType = setupFindingType;
function getFixForControl(control) {
    return ((0, global_1.getDescription)(control.descriptions || [], 'fix') ||
        control.tags.fix ||
        'Fix not available');
}
exports.getFixForControl = getFixForControl;
function setupRemRec(control) {
    return lodash_1.default.truncate(cleanText(`${createNote(control.result)} --- Fix: ${getFixForControl(control)}`), { length: 512, omission: '... [SEE FULL TEXT IN AssumeRolePolicyDocument]' });
}
exports.setupRemRec = setupRemRec;
function setupProdFieldCheck(control) {
    const checkText = (0, global_1.getDescription)(control.descriptions || [], 'check') ||
        control.tags.check ||
        'Check not available';
    return lodash_1.default.truncate(checkText, { length: 2048, omission: '' });
}
exports.setupProdFieldCheck = setupProdFieldCheck;
function setupResourcesID(_val, context) {
    return `AWS::::Account:${context === null || context === void 0 ? void 0 : context.ioptions.awsAccountId}`;
}
exports.setupResourcesID = setupResourcesID;
function setupResourcesID2(control) {
    return `${control.id} Validation Code`;
}
exports.setupResourcesID2 = setupResourcesID2;
function setupDetailsAssume(control) {
    return createAssumeRolePolicyDocument(control.layersOfControl, control.result);
}
exports.setupDetailsAssume = setupDetailsAssume;
function setupControlStatus(control) {
    const status = control.result.status === 'skipped'
        ? 'WARNING'
        : control.result.status === 'passed';
    if (typeof status === 'boolean') {
        return status ? 'PASSED' : 'FAILED';
    }
    return status;
}
exports.setupControlStatus = setupControlStatus;
//# sourceMappingURL=transformers.js.map