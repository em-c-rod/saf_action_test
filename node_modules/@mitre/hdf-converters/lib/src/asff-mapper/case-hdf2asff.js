"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHDF2ASFF = void 0;
const html_entities_1 = require("html-entities");
const lodash_1 = __importDefault(require("lodash"));
const global_1 = require("../utils/global");
const asff_mapper_1 = require("./asff-mapper");
function replaceTypesSlashes(type) {
    if (!lodash_1.default.isString(type)) {
        return type;
    }
    return type.replace(global_1.FROM_ASFF_TYPES_SLASH_REPLACEMENT, '/');
}
function objectifyTypesArray(typesArray) {
    if (!Array.isArray(typesArray)) {
        typesArray = lodash_1.default.get(typesArray, 'FindingProviderFields.Types');
    }
    const ret = {};
    for (const typeString of typesArray) {
        lodash_1.default.merge(ret, (() => {
            const [type, attribute, value] = typeString.split('/');
            let parsed = replaceTypesSlashes(value);
            try {
                parsed = JSON.parse(parsed);
            }
            catch { }
            return { [type]: { [attribute]: parsed } };
        })());
    }
    return ret;
}
function findExecutionFindingIndex(asffOrFindings, asffFindingToMatch) {
    if (asffFindingToMatch) {
        const targetToMatch = asffFindingToMatch.Id.split('/')[0];
        return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
            ? asffOrFindings
            : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2 &&
            lodash_1.default.get(finding, 'Id').startsWith(targetToMatch));
    }
    return lodash_1.default.findIndex(Array.isArray(asffOrFindings)
        ? asffOrFindings
        : lodash_1.default.get(asffOrFindings, 'Findings'), (finding) => lodash_1.default.get(finding, 'Id').split('/').length === 2);
}
function preprocessingASFF(asff) {
    const clone = lodash_1.default.cloneDeep(asff);
    const index = findExecutionFindingIndex(clone);
    lodash_1.default.pullAt(lodash_1.default.get(clone, 'Findings'), index);
    return clone;
}
function supportingDocs(input) {
    const [asff, docs] = input;
    const index = findExecutionFindingIndex(asff);
    const docsClone = lodash_1.default.cloneDeep(docs);
    docsClone.set(asff_mapper_1.SpecialCasing.HDF2ASFF, {
        execution: lodash_1.default.get(asff, `Findings[${index}]`)
    });
    return docsClone;
}
function productName(findings) {
    const finding = Array.isArray(findings) ? findings[0] : findings;
    const name = lodash_1.default.get(finding, 'Id');
    return (0, html_entities_1.encode)(name.split('/').slice(0, 2).join(' - '));
}
function doesNotHaveFindingTitlePrefix() {
    return true;
}
function code(group) {
    return group[0].code || '';
}
function waiverData(group) {
    return group[0].waiver_data || {};
}
function filename(findingInfo) {
    const index = findExecutionFindingIndex(findingInfo[1], findingInfo[0]);
    const target = replaceTypesSlashes(lodash_1.default.get(findingInfo[1][index], 'Id').split('/')[0]);
    const finding = findingInfo[0];
    return `${lodash_1.default.get(objectifyTypesArray(finding), 'File.Input')}-${target}.json`;
}
function getCodeForProfileLayer(finding, profileName) {
    var _a, _b, _c;
    const profileLayerToCodeMapping = {};
    (_c = (_b = (_a = lodash_1.default.get(finding, 'Resources')
        .find((resource) => resource.Type === 'AwsIamRole')) === null || _a === void 0 ? void 0 : _a.Details) === null || _b === void 0 ? void 0 : _b.AwsIamRole) === null || _c === void 0 ? void 0 : _c.AssumeRolePolicyDocument.split('=========================================================\n# Profile name: ').filter((codeLayer) => codeLayer).forEach((codeLayer) => {
        const [profileLevel, code] = codeLayer.split('\n=========================================================\n\n');
        profileLayerToCodeMapping[profileLevel] = code
            .split('Test Description:')[0]
            .trim();
    });
    if (profileName in profileLayerToCodeMapping) {
        return profileLayerToCodeMapping[profileName];
    }
    else {
        return '';
    }
}
function mapping(context) {
    var _a;
    const execution = lodash_1.default.get(context.supportingDocs.get(asff_mapper_1.SpecialCasing.HDF2ASFF), 'execution');
    const executionTypes = objectifyTypesArray(execution);
    const profileNames = Object.keys(executionTypes || {}).filter((type) => !['MITRE', 'File', 'Execution'].includes(type));
    return {
        shortcircuit: true,
        passthrough: lodash_1.default.get(executionTypes, 'Execution.passthrough'),
        platform: {
            ...lodash_1.default.get(executionTypes, 'Execution.platform'),
            target_id: ((_a = context.supportingDocs.get(asff_mapper_1.SpecialCasing.HDF2ASFF)) === null || _a === void 0 ? void 0 : _a.execution.Id).split('/')[0]
        },
        version: lodash_1.default.get(executionTypes, 'Execution.version'),
        statistics: lodash_1.default.get(executionTypes, 'Execution.statistics'),
        profiles: lodash_1.default.map(profileNames, (profileName, index) => {
            return {
                name: lodash_1.default.get(executionTypes, `${profileName}.name`),
                version: lodash_1.default.get(executionTypes, `${profileName}.version`),
                title: lodash_1.default.get(executionTypes, `${profileName}.title`),
                maintainer: lodash_1.default.get(executionTypes, `${profileName}.maintainer`),
                summary: lodash_1.default.get(executionTypes, `${profileName}.summary`),
                license: lodash_1.default.get(executionTypes, `${profileName}.license`),
                copyright: lodash_1.default.get(executionTypes, `${profileName}.copyright`),
                copyright_email: lodash_1.default.get(executionTypes, `${profileName}.copyright_email`),
                supports: lodash_1.default.get(executionTypes, `${profileName}.supports`, []),
                attributes: lodash_1.default.get(executionTypes, `${profileName}.attributes`, []),
                depends: lodash_1.default.get(executionTypes, `${profileName}.depends`),
                groups: [],
                status: lodash_1.default.get(executionTypes, `${profileName}.status`),
                description: lodash_1.default.get(executionTypes, `${profileName}.description`),
                inspec_version: lodash_1.default.get(executionTypes, `${profileName}.inspec_version`),
                parent_profile: lodash_1.default.get(executionTypes, `${profileName}.parent_profile`),
                skip_message: lodash_1.default.get(executionTypes, `${profileName}.skip_message`),
                status_message: lodash_1.default.get(executionTypes, `${profileName}.status_message`),
                controls: (0, asff_mapper_1.consolidate)(context, (() => {
                    return lodash_1.default.map(lodash_1.default.get(context.data, 'Findings'), (finding) => {
                        const findingTypes = objectifyTypesArray(finding);
                        return {
                            id: lodash_1.default.get(findingTypes, 'Control.ID'),
                            ...(lodash_1.default.has(findingTypes, 'Control.Title') && {
                                title: lodash_1.default.get(findingTypes, 'Control.Title')
                            }),
                            ...(lodash_1.default.has(findingTypes, 'Control.Desc') && {
                                desc: lodash_1.default.get(findingTypes, 'Control.Desc')
                            }),
                            impact: lodash_1.default.get(findingTypes, 'Control.Impact'),
                            tags: {
                                ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Tags'), ['nist']),
                                nist: (() => {
                                    const nisttags = lodash_1.default.get(findingTypes, 'Tags.nist');
                                    if (nisttags === undefined || nisttags.length === 0) {
                                        return global_1.DEFAULT_STATIC_CODE_ANALYSIS_NIST_TAGS;
                                    }
                                    return nisttags;
                                })()
                            },
                            descriptions: lodash_1.default.map(Object.entries(lodash_1.default.get(findingTypes, 'Descriptions') || {}), ([key, value]) => ({ label: key, data: value })),
                            refs: lodash_1.default.get(findingTypes, 'Control.Refs', []),
                            source_location: lodash_1.default.get(findingTypes, 'Control.Source_Location', {}),
                            ...(lodash_1.default.has(findingTypes, 'Control.Waiver_Data') && {
                                waiver_data: lodash_1.default.get(findingTypes, 'Control.Waiver_Data')
                            }),
                            code: getCodeForProfileLayer(finding, profileName),
                            results: index === profileNames.length - 1
                                ? [
                                    {
                                        code_desc: lodash_1.default.get(findingTypes, 'Segment.code_desc'),
                                        start_time: lodash_1.default.get(findingTypes, 'Segment.start_time'),
                                        ...lodash_1.default.omit(lodash_1.default.get(findingTypes, 'Segment'), ['code_desc', 'start_time'])
                                    }
                                ]
                                : []
                        };
                    });
                })(), context.data),
                sha256: lodash_1.default.get(executionTypes, `${profileName}.sha256`)
            };
        })
    };
}
function getHDF2ASFF() {
    return {
        preprocessingASFF,
        supportingDocs,
        productName,
        doesNotHaveFindingTitlePrefix,
        code,
        waiverData,
        filename,
        mapping
    };
}
exports.getHDF2ASFF = getHDF2ASFF;
//# sourceMappingURL=case-hdf2asff.js.map