"use strict";
// Utilities to update a profile or control with new metadata
// The ultimate goal is to preserve all the metadata that is already there and only add what is new
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProfileUsingXCCDF = exports.updateProfile = exports.updateControl = exports.findUpdatedControlByAllIdentifiers = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const profile_1 = tslib_1.__importDefault(require("../objects/profile"));
const xccdf_1 = require("../parsers/xccdf");
const diff_1 = require("./diff");
const diffMarkdown_1 = require("./diffMarkdown");
const knownInSpecKeywords = ['title', 'desc', 'impact', 'ref', 'tag', "\""];
function projectValuesOntoExistingObj(dst, src, currentPath = '') {
    for (const updatedValue in src) {
        const existingValue = lodash_1.default.get(dst, updatedValue);
        // We have a new value for something that already exists in dst
        if (existingValue !== undefined) {
            if (typeof existingValue === 'object' && existingValue !== null && !Array.isArray(existingValue)) {
                dst[updatedValue] = projectValuesOntoExistingObj(existingValue, src[updatedValue], currentPath + updatedValue + '.');
            }
            else if (typeof src[updatedValue] === 'string') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue].trim());
            }
            else if (typeof src[updatedValue] === 'number') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue]);
            }
            else if (Array.isArray(src[updatedValue])) {
                const uniqueArrayValues = [...new Set(lodash_1.default.get(dst, updatedValue, []).concat(src[updatedValue]))];
                lodash_1.default.set(dst, updatedValue, uniqueArrayValues);
            }
        }
    }
    return dst;
}
// This is the most likely thing to break if you are getting code formatting issues.
// Extract the existing describe blocks (what is actually run by inspec for validation)
function getExistingDescribeFromControl(control) {
    if (control.code) {
        let existingDescribeBlock = '';
        let currentQuoteEscape = '';
        let percentBlockRegexp = /%[qQriIwWxs]?(?<lDelimiter>[\(\[\{\<])/;
        let inPercentBlock = false;
        let inQuoteBlock = false;
        let inMetadataValueOverride = false;
        let indentedMetadataOverride = false;
        let inDescribeBlock = false;
        let mostSpacesSeen = 0;
        let lDelimiter = '(';
        let rDelimiter = ')';
        control.code.split('\n').forEach((line) => {
            const wordArray = line.trim().split(' ');
            const spaces = line.substring(0, line.indexOf(wordArray[0])).length;
            if (spaces - mostSpacesSeen > 10) {
                indentedMetadataOverride = true;
            }
            else {
                mostSpacesSeen = spaces;
                indentedMetadataOverride = false;
            }
            if ((!inPercentBlock && !inQuoteBlock && !inMetadataValueOverride && !indentedMetadataOverride) || inDescribeBlock) {
                if (inDescribeBlock && wordArray.length === 1 && wordArray.includes('')) {
                    existingDescribeBlock += '\n';
                }
                // Get the number of spaces at the beginning of the current line
                else if (spaces >= 2) {
                    const firstWord = wordArray[0];
                    if (knownInSpecKeywords.indexOf(firstWord.toLowerCase()) === -1 || (knownInSpecKeywords.indexOf(firstWord.toLowerCase()) !== -1 && spaces > 2) || inDescribeBlock) {
                        inDescribeBlock = true;
                        existingDescribeBlock += line + '\n';
                    }
                }
            }
            wordArray.forEach((word, index) => {
                //console.log(`LDELIMITER:   \"${lDelimiter}\"   RDELIMITER:   \"${rDelimiter}\"`)
                let percentBlockMatch = percentBlockRegexp.exec(word);
                if (percentBlockMatch && inPercentBlock === false) {
                    inPercentBlock = true;
                    lDelimiter = percentBlockMatch.groups.lDelimiter || '(';
                    switch (lDelimiter) {
                        case '{': {
                            rDelimiter = '}';
                            break;
                        }
                        case '[': {
                            rDelimiter = ']';
                            break;
                        }
                        case '<': {
                            rDelimiter = '>';
                            break;
                        }
                        default: {
                            break;
                        }
                    }
                }
                const charArray = word.split('');
                charArray.forEach((char, index) => {
                    if (inPercentBlock) {
                        if (char === rDelimiter && charArray[index - 1] !== '\\' && !inQuoteBlock) {
                            inPercentBlock = false;
                        }
                    }
                    if (char === '"' && charArray[index - 1] !== '\\') {
                        if (!currentQuoteEscape || !inQuoteBlock) {
                            currentQuoteEscape = '"';
                        }
                        if (currentQuoteEscape === '"') {
                            inQuoteBlock = !inQuoteBlock;
                        }
                    }
                    else if (char === "'" && charArray[index - 1] !== '\\') {
                        if (!currentQuoteEscape || !inQuoteBlock) {
                            currentQuoteEscape = "'";
                        }
                        if (currentQuoteEscape === "'") {
                            inQuoteBlock = !inQuoteBlock;
                        }
                    }
                });
            });
        });
        // Take off the extra newline at the end
        return existingDescribeBlock.slice(0, -1);
    }
    else {
        return '';
    }
}
function findUpdatedControlByAllIdentifiers(existingControl, updatedControls) {
    // Try to match based on IDs
    let updatedControl = updatedControls.find((updatedControl) => {
        return updatedControl.id.toLowerCase() === existingControl.id.toLowerCase();
    });
    if (updatedControl) {
        return updatedControl;
    }
    // Try to match based on legacy identifiers
    updatedControl = updatedControls.find((updatedControl) => {
        var _a;
        return (_a = updatedControl.tags.legacy) === null || _a === void 0 ? void 0 : _a.some((legacyTag) => {
            var _a;
            return legacyTag.toLowerCase() === ((_a = existingControl.id) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        });
    });
    if (updatedControl) {
        return updatedControl;
    }
    return undefined;
}
exports.findUpdatedControlByAllIdentifiers = findUpdatedControlByAllIdentifiers;
function updateControl(from, update, logger) {
    const existingDescribeBlock = getExistingDescribeFromControl(from);
    logger.debug(`Existing describe block for control ${from.id}: ${JSON.stringify(existingDescribeBlock)}`);
    const projectedControl = projectValuesOntoExistingObj(from, update);
    projectedControl.describe = existingDescribeBlock;
    return projectedControl;
}
exports.updateControl = updateControl;
function updateProfile(from, using, logger) {
    // Update the profile with the new metadata
    const to = new profile_1.default(lodash_1.default.omit(from, 'controls'));
    // Find the diff
    const diff = (0, diff_1.diffProfile)(from, using, logger);
    // Add the new controls
    diff.ignoreFormattingDiff.addedControlIDs.forEach(id => {
        const addedControl = diff.ignoreFormattingDiff.addedControls[id];
        if (addedControl) {
            logger.debug(`New Control: ${addedControl.id} - ${addedControl.title}`);
            to.controls.push(addedControl);
        }
        else {
            throw new Error(`New control ${id} added but don't have the control data`);
        }
    });
    // Update the existing controls
    for (const existingControl of from.controls) {
        const updatedControl = findUpdatedControlByAllIdentifiers(existingControl, using.controls);
        if (updatedControl) {
            const controlDiff = diff.ignoreFormattingDiff.changedControls[updatedControl.id];
            if (controlDiff) {
                to.controls.push(updateControl(existingControl, controlDiff, logger));
            }
            else {
                to.controls.push(existingControl);
            }
        }
    }
    return {
        profile: to,
        diff,
    };
}
exports.updateProfile = updateProfile;
function updateProfileUsingXCCDF(from, using, id, logger, ovalDefinitions) {
    logger.debug(`Updating profile ${from.name} with control IDs: ${id}`);
    // Parse the XCCDF benchmark and convert it into a Profile
    logger.debug('Loading XCCDF File');
    const xccdfProfile = (0, xccdf_1.processXCCDF)(using, false, id, ovalDefinitions);
    logger.debug('Loaded XCCDF File');
    // Update the profile and return
    logger.debug('Creating updated profile');
    const updatedProfile = updateProfile(from, xccdfProfile, logger);
    logger.debug('Creating diff markdown');
    // Create the markdown
    const markdown = (0, diffMarkdown_1.createDiffMarkdown)(updatedProfile.diff);
    logger.debug('Profile update complete');
    return {
        profile: updatedProfile.profile,
        diff: updatedProfile.diff,
        markdown: markdown
    };
}
exports.updateProfileUsingXCCDF = updateProfileUsingXCCDF;
