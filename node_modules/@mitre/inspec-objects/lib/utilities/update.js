"use strict";
// Utilities to update a profile or control with new metadata
// The ultimate goal is to preserve all the metadata that is already there and only add what is new
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateProfileUsingXCCDF = exports.updateProfile = exports.updateControl = exports.findUpdatedControlByAllIdentifiers = exports.getExistingDescribeFromControl = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const profile_1 = tslib_1.__importDefault(require("../objects/profile"));
const xccdf_1 = require("../parsers/xccdf");
const diff_1 = require("./diff");
const diffMarkdown_1 = require("./diffMarkdown");
function projectValuesOntoExistingObj(dst, src, currentPath = '') {
    for (const updatedValue in src) {
        const existingValue = lodash_1.default.get(dst, updatedValue);
        // We have a new value for something that already exists in dst
        if (existingValue !== undefined) {
            if (typeof existingValue === 'object' && existingValue !== null && !Array.isArray(existingValue)) {
                dst[updatedValue] = projectValuesOntoExistingObj(existingValue, src[updatedValue], currentPath + updatedValue + '.');
            }
            else if (typeof src[updatedValue] === 'string') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue].trim());
            }
            else if (typeof src[updatedValue] === 'number') {
                lodash_1.default.set(dst, updatedValue, src[updatedValue]);
            }
            else if (Array.isArray(src[updatedValue])) {
                const uniqueArrayValues = [...new Set(lodash_1.default.get(dst, updatedValue, []).concat(src[updatedValue]))];
                lodash_1.default.set(dst, updatedValue, uniqueArrayValues);
            }
        }
    }
    return dst;
}
/*
  Return first index found from given array that is not an empty entry (cell)
*/
function getIndexOfFirstLine(auditArray, index, action) {
    let indexVal = index;
    while (auditArray[indexVal] === '') {
        switch (action) {
            case '-':
                indexVal--;
                break;
            case '+':
                indexVal++;
                break;
        }
    }
    return indexVal;
}
/*
  This is the most likely thing to break if you are getting code formatting issues.
  Extract the existing describe blocks (what is actually run by inspec for validation)
*/
function getExistingDescribeFromControl(control) {
    // Algorithm:
    //   Locate the start and end of the control string
    //   Update the end of the control that contains information (if empty lines are at the end of the control)
    //   loop: until the start index is changed (loop is done from the bottom up)
    //     Clean testing array entry line (removes any non-print characters)
    //     if: line starts with meta-information 'tag' or 'ref'
    //       set start index to found location
    //       break out of the loop
    //     end
    //   end
    //   Remove any empty lines after the start index (in any)
    //   Extract the describe block from the audit control given the start and end indices
    // Assumptions: 
    //  1 - The meta-information 'tag' or 'ref' precedes the describe block
    // Pros: Solves the potential issue with option 1, as the lookup for the meta-information
    //       'tag' or 'ref' is expected to the at the beginning of the line.
    if (control.code) {
        let existingDescribeBlock = '';
        let indexStart = control.code.toLowerCase().indexOf('control');
        let indexEnd = control.code.toLowerCase().trimEnd().lastIndexOf('end');
        const auditControl = control.code.substring(indexStart, indexEnd).split('\n');
        indexStart = 0;
        indexEnd = auditControl.length - 1;
        indexEnd = getIndexOfFirstLine(auditControl, indexEnd, '-');
        let index = indexEnd;
        while (indexStart === 0) {
            const line = auditControl[index].toLowerCase().trim();
            if (line.indexOf('ref') === 0 || line.indexOf('tag') === 0) {
                indexStart = index + 1;
            }
            index--;
        }
        indexStart = getIndexOfFirstLine(auditControl, indexStart, '+');
        existingDescribeBlock = auditControl.slice(indexStart, indexEnd + 1).join('\n').toString();
        return existingDescribeBlock;
    }
    else {
        return '';
    }
}
exports.getExistingDescribeFromControl = getExistingDescribeFromControl;
function findUpdatedControlByAllIdentifiers(existingControl, updatedControls) {
    // Try to match based on IDs
    let updatedControl = updatedControls.find((updatedControl) => {
        return updatedControl.id.toLowerCase() === existingControl.id.toLowerCase();
    });
    if (updatedControl) {
        return updatedControl;
    }
    // Try to match based on legacy identifiers
    updatedControl = updatedControls.find((updatedControl) => {
        var _a;
        return (_a = updatedControl.tags.legacy) === null || _a === void 0 ? void 0 : _a.some((legacyTag) => {
            var _a;
            return legacyTag.toLowerCase() === ((_a = existingControl.id) === null || _a === void 0 ? void 0 : _a.toLowerCase());
        });
    });
    if (updatedControl) {
        return updatedControl;
    }
    return undefined;
}
exports.findUpdatedControlByAllIdentifiers = findUpdatedControlByAllIdentifiers;
function updateControl(from, update, logger) {
    const existingDescribeBlock = getExistingDescribeFromControl(from);
    logger.debug(`Existing describe block for control ${from.id}: ${JSON.stringify(existingDescribeBlock)}`);
    const projectedControl = projectValuesOntoExistingObj(from, update);
    projectedControl.describe = existingDescribeBlock;
    return projectedControl;
}
exports.updateControl = updateControl;
function updateProfile(from, using, logger) {
    // Update the profile with the new metadata
    const to = new profile_1.default(lodash_1.default.omit(from, 'controls'));
    // Find the diff
    const diff = (0, diff_1.diffProfile)(from, using, logger);
    // Add the new controls
    diff.ignoreFormattingDiff.addedControlIDs.forEach(id => {
        const addedControl = diff.ignoreFormattingDiff.addedControls[id];
        if (addedControl) {
            logger.debug(`New Control: ${addedControl.id} - ${addedControl.title}`);
            to.controls.push(addedControl);
        }
        else {
            throw new Error(`New control ${id} added but don't have the control data`);
        }
    });
    // Update the existing controls
    for (const existingControl of from.controls) {
        const updatedControl = findUpdatedControlByAllIdentifiers(existingControl, using.controls);
        if (updatedControl) {
            const controlDiff = diff.ignoreFormattingDiff.changedControls[updatedControl.id];
            if (controlDiff) {
                to.controls.push(updateControl(existingControl, controlDiff, logger));
            }
            else {
                to.controls.push(existingControl);
            }
        }
    }
    return {
        profile: to,
        diff,
    };
}
exports.updateProfile = updateProfile;
function updateProfileUsingXCCDF(from, using, id, logger, ovalDefinitions) {
    logger.debug(`Updating profile ${from.name} with control IDs: ${id}`);
    // Parse the XCCDF benchmark and convert it into a Profile
    logger.debug('Loading XCCDF File');
    const xccdfProfile = (0, xccdf_1.processXCCDF)(using, false, id, ovalDefinitions);
    logger.debug('Loaded XCCDF File');
    // Update the profile and return
    logger.debug('Creating updated profile');
    const updatedProfile = updateProfile(from, xccdfProfile, logger);
    logger.debug('Creating diff markdown');
    // Create the markdown
    const markdown = (0, diffMarkdown_1.createDiffMarkdown)(updatedProfile.diff);
    logger.debug('Profile update complete');
    return {
        profile: updatedProfile.profile,
        diff: updatedProfile.diff,
        markdown: markdown
    };
}
exports.updateProfileUsingXCCDF = updateProfileUsingXCCDF;
