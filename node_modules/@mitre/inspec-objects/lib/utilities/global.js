"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasPath = exports.getFirstPath = exports.removeNewlinePlaceholders = exports.wrapAndEscapeQuotes = exports.escapeDoubleQuotes = exports.escapeQuotes = exports.unformatText = exports.wrap = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
// Breaks lines down to lineLength number of characters
function wrap(s, lineLength = 80) {
    let newString = "";
    let currentLine = "";
    let currentLength = 0;
    let shouldBreakLine = false;
    for (var i = 0; i < s.length; i++) {
        if (shouldBreakLine) {
            newString += `\n`;
            currentLength = 0;
            shouldBreakLine = false;
        }
        let currentChar = s.charAt(i);
        let nextChar = s.charAt(i + 1);
        if (nextChar === " ") {
            if (currentLength >= lineLength) {
                shouldBreakLine = true;
                newString += currentChar;
                currentLength++;
            }
            else {
                newString += currentChar;
                currentLength++;
            }
        }
        else {
            newString += currentChar;
            currentLength++;
        }
    }
    return newString;
}
exports.wrap = wrap;
function unformatText(s) {
    return s.replace(/\n/g, ' ').replace(/\\n/g, ' ').replace(/( +|\t)/g, ' ');
}
exports.unformatText = unformatText;
const escapeQuotes = (s) => s.replace(/\\/g, "\\\\").replace(/'/g, "\\'"); // Escape backslashes and quotes
exports.escapeQuotes = escapeQuotes;
const escapeDoubleQuotes = (s) => s.replace(/\\/g, "\\\\").replace(/"/g, '\\"'); // Escape backslashes and double quotes
exports.escapeDoubleQuotes = escapeDoubleQuotes;
const wrapAndEscapeQuotes = (s, lineLength) => escapeDoubleQuotes(wrap(s, lineLength)); // Escape backslashes and quotes, and wrap long lines
exports.wrapAndEscapeQuotes = wrapAndEscapeQuotes;
function removeNewlinePlaceholders(s) {
    return s.replace(/\{\{\{\{newlineHERE\}\}\}\}/g, '\n');
}
exports.removeNewlinePlaceholders = removeNewlinePlaceholders;
function getFirstPath(object, paths) {
    const index = lodash_1.default.findIndex(paths, (p) => hasPath(object, p));
    if (index === -1) {
        throw new Error(`Attestation is missing one of these paths: ${paths.join(', ')}`);
    }
    else {
        return lodash_1.default.get(object, paths[index]);
    }
}
exports.getFirstPath = getFirstPath;
function hasPath(file, path) {
    let pathArray;
    if (typeof path === 'string') {
        pathArray = [path];
    }
    else {
        pathArray = path;
    }
    return lodash_1.default.some(pathArray, (p) => lodash_1.default.has(file, p));
}
exports.hasPath = hasPath;
